<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>캘리그라피 합성기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Jua', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Jua', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            height: 100dvh; /* 동적 뷰포트 높이 사용 (모바일 최적화) */
            max-height: 100vh;
            max-height: 100dvh; /* 동적 뷰포트 높이 사용 */
            overflow: hidden; /* 스크롤 완전 방지 */
            margin: 0;
            padding: 0;
            /* 모바일 터치 최적화 */
            touch-action: none; /* 모든 터치 액션 방지 */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* 터치 스크롤 방지 */
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: none;
        }
        
        /* 모바일 뷰포트 높이 보정 */
        @supports (height: 100dvh) {
            body {
                height: 100dvh;
                max-height: 100dvh;
            }
        }
        
        /* iOS Safari 주소창 고려한 높이 계산 */
        @media screen and (max-width: 768px) {
            body {
                height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
                max-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
            }
            
            @supports (height: 100dvh) {
                body {
                    height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
                    max-height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
                }
            }
        }
        
        /* 모든 요소에 Jua 폰트 강제 적용 */
        *, *::before, *::after {
            font-family: 'Jua', sans-serif !important;
        }
        
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .custom-modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 90vw;
            max-height: 90vh;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        .custom-modal h3 {
            font-size: 1.5rem;
            /* font-weight: bold; */
            margin-bottom: 20px;
            color: #333;
        }
        
        .custom-modal p {
            margin-bottom: 20px;
            color: #666;
        }
        
        .custom-modal button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: transform 0.2s;
        }
        
        .custom-modal button:hover {
            transform: translateY(-2px);
        }
        
        .custom-modal button.secondary {
            background: #e5e7eb;
            color: #374151;
        }
        
        .step {
            display: none;
            height: 100vh;
            height: 100dvh; /* 동적 뷰포트 높이 사용 */
            overflow: hidden; /* 스크롤 방지 */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1;
        }
        
        .step.active {
            display: block;
            height: 100vh;
            height: 100dvh; /* 동적 뷰포트 높이 사용 */
            overflow: hidden; /* 스크롤 방지 */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1;
        }
        
        /* 모바일에서 스텝 높이 보정 */
        @media screen and (max-width: 768px) {
            .step, .step.active {
                height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
            }
            
            @supports (height: 100dvh) {
                .step, .step.active {
                    height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
                }
            }
        }
        
        .image-preview {
            max-width: 100%;
            max-height: 60vh;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin: 20px auto;
            display: block;
            object-fit: contain;
            object-position: center;
        }
        
        .crop-overlay {
            position: relative;
            display: inline-block;
            border-radius: 10px;
            overflow: hidden;
            max-width: 90vw;
            max-height: 70vh;
        }
        
        .crop-area {
            position: absolute;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            cursor: move;
            z-index: 5;
            pointer-events: auto;
            /* 모바일 터치 최적화 */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .crop-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #667eea;
            border: 3px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 15;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            /* 모바일 터치 최적화 */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* 항상 보이도록 강제 */
            opacity: 1 !important;
            visibility: visible !important;
            display: block !important;
        }
        
        .crop-handle:hover {
            background: #5a67d8;
            transform: scale(1.1);
        }
        
        .crop-handle.nw { top: -10px; left: -10px; cursor: nw-resize; }
        .crop-handle.ne { top: -10px; right: -10px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -10px; left: -10px; cursor: sw-resize; }
        .crop-handle.se { bottom: -10px; right: -10px; cursor: se-resize; }
        
        .crop-handle.n { top: -10px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .crop-handle.s { bottom: -10px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .crop-handle.w { left: -10px; top: 50%; transform: translateY(-50%); cursor: w-resize; }
        .crop-handle.e { right: -10px; top: 50%; transform: translateY(-50%); cursor: e-resize; }
        
        .composite-preview-container {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            width: 100% !important;
            height: calc(100vh - 250px); /* 위/아래 버튼 공간 제외하고 최대 높이 */
            height: calc(100dvh - 250px); /* 동적 뷰포트 높이 사용 */
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            position: static;
            margin-bottom: 20px;
            overflow: hidden; /* 스크롤 방지 */
        }
        
        /* 모바일에서 컴포지트 프리뷰 높이 보정 */
        @media screen and (max-width: 768px) {
            .composite-preview-container {
                height: calc(100vh - 500px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
                margin-bottom: 60px; /* 하단 여백 더 증가 */
                padding-bottom: 40px;
            }
            
            @supports (height: 100dvh) {
                .composite-preview-container {
                    height: calc(100dvh - 500px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
                }
            }
            
            /* 모든 단계 버튼 영역 안전 여백 */
            .step-1 .text-center.mt-8,
            .step-2 .text-center.mt-6,
            .step-3 .text-center.mt-6 {
                padding-bottom: calc(20px + env(safe-area-inset-bottom));
                margin-bottom: 20px;
            }
            
            /* 모든 단계 버튼 */
            .step-1 button,
            .step-2 button,
            .step-3 button {
                margin-bottom: calc(10px + env(safe-area-inset-bottom));
            }
        }
        
        /* 모바일 버튼 영역 안전 여백 */
        @media screen and (max-width: 768px) {
            /* 첫 페이지 컨테이너 안전 여백 */
            .step-1 .container {
                padding-bottom: calc(20px + env(safe-area-inset-bottom));
            }
            
            .flex.justify-center.space-x-4 {
                padding-bottom: calc(20px + env(safe-area-inset-bottom));
                margin-bottom: 20px;
            }
            
            /* 다운로드 버튼 특별 처리 */
            #downloadBtn {
                margin-bottom: calc(10px + env(safe-area-inset-bottom));
            }
            
            /* 전체 버튼 컨테이너에 안전 여백 */
            .step-4 .flex.justify-center.space-x-4 {
                position: relative;
                z-index: 10;
                background: rgba(102, 126, 234, 0.1);
                backdrop-filter: blur(10px);
                border-radius: 20px 20px 0 0;
                padding: 20px;
                padding-bottom: calc(20px + env(safe-area-inset-bottom));
            }
        }
        
        .composite-preview {
            position: relative;
            display: block;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            background: transparent;
            margin: 0 auto !important;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            text-align: center;
            aspect-ratio: auto;
        }
        
        /* 770px 이상에서 컨테이너 크기 고정 */
        @media (min-width: 770px) {
            .composite-preview-container {
                height: calc(100vh - 200px); /* 위/아래 버튼 공간 제외하고 최대 높이 */
                padding: 20px;
                width: 100% !important;
            }
            
            .composite-preview {
                max-width: 100%;
                max-height: 100%;
                width: 100%;
                height: 100%;
            }
        }
        
        /* 1200px 이상에서 더 큰 컨테이너 */
        @media (min-width: 1200px) {
            .composite-preview-container {
                height: calc(100vh - 250px); /* 위/아래 버튼 공간 제외하고 최대 높이 */
                padding: 30px;
            }
            
            .composite-preview {
                max-width: 100%;
                max-height: 100%;
                width: 100%;
                height: 100%;
            }
        }
        
        /* 480px 이하에서 모바일 최적화 */
        @media (max-width: 480px) {
            .composite-preview-container {
                height: calc(100vh - 250px); /* 위/아래 버튼 공간 제외하고 최대 높이 */
                padding: 5px;
                overflow: hidden; /* 스크롤 방지 */
            }
            
            .composite-preview {
                max-width: 100%;
                max-height: 100%;
                width: 100%;
                height: 100%;
            }

            /* 모바일에서 핸들 크기 증가 */
            .edit-handle {
                width: 50px !important;
                height: 50px !important;
                min-width: 50px !important;
                min-height: 50px !important;
                max-width: 50px !important;
                max-height: 50px !important;
                font-size: 20px;
            }

            .crop-handle {
                width: 36px;
                height: 36px;
                border: 4px solid white;
                box-shadow: 0 3px 12px rgba(0,0,0,0.4);
            }

            /* 모바일에서 컨테이너 높이 조정 */
            .container {
                height: 100vh;
                overflow: hidden;
            }

            .control-panel {
                max-height: calc(100vh - 100px);
                overflow: hidden;
            }
        }
        
        .composite-preview .background-image {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            object-position: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* 배경 이미지가 컨테이너에 맞게 전체가 보이도록 조정 */
        .composite-preview {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            position: relative;
            overflow: hidden;
        }
        
        .composite-preview .calligraphy-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            cursor: move;
            background: transparent;
            /* 모바일 터치 최적화 */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .composite-preview .calligraphy-overlay img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        /* calligraphyOverlay 내부의 편집 핸들 스타일 */
        .calligraphy-overlay .edit-handles {
            position: absolute !important;
            pointer-events: auto !important;
            z-index: 10 !important;
            opacity: 1 !important;
            visibility: visible !important;
            display: block !important;
            margin: 0 !important;
            padding: 0 !important;
            box-sizing: border-box !important;
        }
        
        .calligraphy-overlay .edit-handles::before {
            border: 3px solid #667eea !important;
            background: transparent !important;
            margin: 0 !important;
            padding: 0 !important;
            box-sizing: border-box !important;
        }
        
        .calligraphy-overlay .edit-handle {
            opacity: 1 !important;
            visibility: visible !important;
            display: flex !important;
            position: absolute !important;
        }
        
        .edit-handles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto !important;
            box-sizing: border-box;
            z-index: 10;
            overflow: visible;
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            /* 글씨 이미지와 완전 동기화를 위한 설정 */
            transform-origin: center;
            will-change: transform, left, top, width, height;
        }
        
        .edit-handles::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid #667eea; /* 테두리를 더 굵게 */
            background: transparent; /* 배경색 제거 */
            pointer-events: none;
            box-sizing: border-box;
        }
        
        /* 편집 핸들이 calligraphy-overlay와 동일한 transform을 가지도록 */
        .edit-handles {
            transform-origin: center;
        }
        
        .crop-outline {
            position: absolute;
            border: 2px solid #667eea;
            /* background: rgba(102, 126, 234, 0.1); */
            pointer-events: none;
            box-sizing: border-box;
            z-index: 5;
        }
        
        .edit-handle {
            position: absolute;
            width: 40px !important;
            height: 40px !important;
            background: #667eea;
            border: 3px solid #ffffff;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            box-shadow: 0 4px 8px rgba(0,0,0,0.6);
            transition: all 0.2s ease;
            mix-blend-mode: normal !important;
            filter: none !important;
            transform: none !important;
            min-width: 40px !important;
            min-height: 40px !important;
            max-width: 40px !important;
            max-height: 40px !important;
            opacity: 1 !important; /* 항상 보이도록 강제 */
            visibility: visible !important; /* 항상 보이도록 강제 */
            /* 모바일 터치 최적화 */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .edit-handle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.8);
            background: #333333;
        }
        
        .edit-handle.scale {
            bottom: -20px;
            right: -20px;
            cursor: se-resize;
        }
        
        .edit-handle.rotate {
            top: -20px;
            right: -20px;
            cursor: grab;
        }
        
        .edit-handle.rotate:active {
            cursor: grabbing;
        }
        
        /* 아이콘이 부모의 스케일 변환에 영향받지 않도록 */
        .calligraphy-overlay {
            transform-origin: center;
        }
        
        .edit-handles {
            transform-origin: center;
        }
        
        .edit-handle {
            transform-origin: center !important;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #374151;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .control-group input[type="color"] {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .blend-mode-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .blend-mode-buttons button {
            padding: 12px 32px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            font-weight: bold;
            margin: 0 10px;
        }
        
        .blend-mode-buttons button.active {
            transform: translateY(-2px);
        }
        
        .blend-mode-buttons button#multiplyMode.active {
            background: white;
            color: black;
        }
        
        .blend-mode-buttons button#screenMode {
            background: black;
            color: white;
        }
        
        .blend-mode-buttons button#screenMode.active {
            background: black;
            color: white;
        }
        
        .file-upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            background: #f8fafc;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .file-upload-area:hover {
            border-color: #667eea;
            background: #f1f5f9;
        }
        
        .file-upload-area.dragover {
            border-color: #667eea;
            background: #e0e7ff;
        }
        
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }
        
        .back-button:hover {
            background: white;
            transform: scale(1.1);
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .step-indicator {
            display: flex;
            justify-content: center;
            margin-top: 30px;
            margin-bottom: 0;
        }
        
        .step-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            margin: 0 8px;
            transition: all 0.3s;
        }
        
        .step-dot.active {
            background: #ffffff;
            transform: scale(1.2);
        }
        
        .step-dot.completed {
            background: rgba(255, 255, 255, 0.5);
        }
        
        #menu-hamburger:hover {
          background: rgba(255,255,255,0.18) !important;
        }
    </style>
</head>
<body>
    <!-- 햄버거 메뉴 버튼 및 메뉴 -->
    <div id="menu-hamburger" style="position:fixed;top:24px;right:28px;z-index:9999;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;background:transparent;border-radius:50%;transition:background 0.18s;">
      <div style="width:26px;height:20px;display:flex;flex-direction:column;justify-content:space-between;">
        <span class="menu-bar" style="display:block;height:4px;width:100%;background:#fff;border-radius:2px;"></span>
        <span class="menu-bar" style="display:block;height:4px;width:100%;background:#fff;border-radius:2px;"></span>
        <span class="menu-bar" style="display:block;height:4px;width:100%;background:#fff;border-radius:2px;"></span>
      </div>
    </div>
    <div id="menu-popup" style="display:none;position:fixed;top:70px;right:32px;z-index:10000;background:#fff;border-radius:16px;box-shadow:0 4px 24px #0003;padding:18px 28px 14px 28px;min-width:180px;text-align:left;">
      <div style="font-size:1.08rem;font-weight:bold;color:#667eea;margin-bottom:10px;">메뉴</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='index.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">뽀모도로 타이머</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='infiniteStairs.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">무한의 계단</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='website.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">웹사이트</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='habitTracker/index.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">습관 추적기</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='survey/index.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">설문조사</div>
    </div>
    
    <!-- 뒤로가기 버튼 -->
    <button class="back-button" onclick="goBack()" style="display: none;">←</button>
    
    <!-- 단계 1: 배경 이미지 업로드 -->
    <div class="step active" id="step1">
        <div class="container mx-auto px-4 py-4">
            <h1 class="text-3xl text-center text-white mb-8">캘리그라피 합성기</h1>
            
            <div class="max-w-2xl mx-auto">
                    <div class="control-panel">
                        <h2 class="text-xl mb-4 text-center">1. 배경 사진 업로드</h2>
                        <div class="file-upload-area" id="backgroundUploadArea" onclick="document.getElementById('backgroundInput').click()">
                            <div class="text-6xl mb-4">🖼️</div>
                            <p class="text-lg  mb-2">배경 사진을 선택하세요</p>
                            <p class="text-gray-600">클릭하거나 드래그하여 업로드</p>
                            <input type="file" id="backgroundInput" accept="image/*" style="display: none;">
                        </div>
                        <div id="backgroundCheckArea" class="mt-4" style="display: none;">
                            <div class="text-center">
                                <div class="text-6xl mb-4 text-green-500">✅</div>
                                <p class="text-lg text-green-600 font-semibold">배경 사진이 업로드되었습니다</p>
                            </div>
                        </div>
                    </div>
                    
                <div class="text-center mt-8" id="nextButtonContainer" style="display: none;">
                    <button id="nextToStep2" class="bg-white text-purple-600 px-8 py-3 rounded-full  text-lg shadow-lg hover:shadow-xl transition-all">
                        다음
                    </button>
                </div>
            </div>
            
            <!-- 단계 표시기 -->
            <div class="step-indicator">
                <div class="step-dot active" data-step="1"></div>
                <div class="step-dot" data-step="2"></div>
                <div class="step-dot" data-step="3"></div>
                <div class="step-dot" data-step="4"></div>
            </div>
        </div>
    </div>
    
    <!-- 단계 2: 글씨 이미지 업로드 -->
    <div class="step" id="step2">
        <div class="container mx-auto px-4 py-4">
            <h1 class="text-3xl text-center text-white mb-8">글씨 사진 업로드</h1>
            
            <div class="max-w-2xl mx-auto">
                    <div class="control-panel">
                    <h2 class="text-xl mb-4 text-center">2. 글씨 사진 업로드</h2>
                        <div class="file-upload-area" onclick="document.getElementById('calligraphyInput').click()">
                            <div class="text-6xl mb-4">✍️</div>
                            <p class="text-lg  mb-2">글씨 사진을 선택하세요</p>
                            <p class="text-gray-600">클릭하거나 드래그하여 업로드</p>
                            <input type="file" id="calligraphyInput" accept="image/*" style="display: none;">
                        </div>
                  
                </div>
                
            </div>
            
            <!-- 단계 표시기 -->
            <div class="step-indicator">
                <div class="step-dot" data-step="1"></div>
                <div class="step-dot active" data-step="2"></div>
                <div class="step-dot" data-step="3"></div>
                <div class="step-dot" data-step="4"></div>
            </div>
        </div>
    </div>
    
    <!-- 단계 3: 글씨 사진 보정 및 자르기 -->
    <div class="step" id="step3">
        <div class="container mx-auto px-4 py-4">
            <h1 class="text-3xl  text-center text-white mb-8">글씨 부분 자르기</h1>
            
            <div class="max-w-7xl mx-auto">
                <div class="control-panel">
                    
                    <div class="text-center">
                        <div class="crop-overlay" id="cropContainer">
                            <img id="processedCalligraphy" class="image-preview" alt="보정된 글씨">
                            <div class="crop-area" id="cropArea"></div>
                        </div>
                        
                    </div>
                    
                    <div class="text-center mt-6">
                        <button id="nextToStep4" class="bg-purple-500 text-white px-8 py-3 rounded-full  text-lg shadow-lg hover:shadow-xl transition-all">
                            자르기 완료
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 단계 표시기 -->
            <div class="step-indicator">
                <div class="step-dot" data-step="1"></div>
                <div class="step-dot" data-step="2"></div>
                <div class="step-dot active" data-step="3"></div>
                <div class="step-dot" data-step="4"></div>
            </div>
        </div>
    </div>
    
    <!-- 단계 4: 사진 합성 및 편집 -->
    <div class="step" id="step4">
        <div class="container mx-auto px-4 py-4">
                        
            <div class="max-w-6xl mx-auto">
                <div class="grid md:grid-cols-2 gap-8">
                    <!-- 미리보기 영역 -->
                    <div class="control-panel">
                        <div class="control-group mt-4">
                            <div class="blend-mode-buttons justify-center">
                                <button id="multiplyMode" class="active bg-white text-black px-8 py-3 rounded-full text-base shadow-lg hover:shadow-xl transition-all">검은 글씨</button>
                                <button id="screenMode" class="bg-black text-white px-8 py-3 rounded-full text-base shadow-lg hover:shadow-xl transition-all">흰 글씨</button>
                            </div>
                        </div>
                        <div class="composite-preview-container">
                            <div class="composite-preview" id="compositePreview">
                                <img id="compositeBackground" class="background-image" alt="합성 미리보기">
                                <div class="calligraphy-overlay" id="calligraphyOverlay">
                                    <img id="compositeCalligraphy" alt="글씨 오버레이">
                                    <div class="edit-handles" id="editHandles">
                                        <div class="edit-handle scale" id="scaleHandle">↘</div>
                                        <div class="edit-handle rotate" id="rotateHandle">↻</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 색상 및 블렌드 모드 -->
                        
                        
                        <div class="text-center mt-6 space-x-4">
                            <button id="restartBtn" class="bg-gray-500 text-white px-8 py-3 rounded-full  text-base shadow-lg hover:shadow-xl transition-all">
                                다시 시작
                            </button>
                            <button id="downloadBtn" class="bg-purple-500 text-white px-8 py-3 rounded-full  text-base shadow-lg hover:shadow-xl transition-all">
                                다운로드
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 단계 표시기 -->
            <div class="step-indicator">
                <div class="step-dot" data-step="1"></div>
                <div class="step-dot" data-step="2"></div>
                <div class="step-dot" data-step="3"></div>
                <div class="step-dot active" data-step="4"></div>
            </div>
        </div>
    </div>
    
    
    <!-- 커스텀 모달 -->
    <div class="custom-modal" id="customModal">
        <div class="custom-modal-content">
            <h3 id="modalTitle">알림</h3>
            <p id="modalMessage">메시지가 여기에 표시됩니다.</p>
            <div>
                <button id="modalConfirm" onclick="closeModal()">확인</button>
                <button id="modalCancel" onclick="closeModal()" class="secondary" style="display: none;">취소</button>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let backgroundImage = null;
        let calligraphyImage = null;
        let processedCalligraphy = null;
        let croppedCalligraphy = null;
        let currentStep = 1;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let currentPosition = { x: 50, y: 50 }; // 퍼센트
        let currentScale = 0.3; // 배경의 30% 크기로 시작 (더 작게)
        let currentRotation = 0;
        let currentBlendMode = 'multiply';
        // cropArea는 이제 cropSystem.cropArea로 관리됨
        
        // DOM 요소
        const steps = document.querySelectorAll('.step');
        const stepDots = document.querySelectorAll('.step-dot');
        const backgroundInput = document.getElementById('backgroundInput');
        const calligraphyInput = document.getElementById('calligraphyInput');
        const backgroundPreview = document.getElementById('backgroundPreview');
        const calligraphyPreview = document.getElementById('calligraphyPreview');
        const backgroundImageEl = document.getElementById('backgroundImage');
        const calligraphyImageEl = document.getElementById('calligraphyImage');
        const processedCalligraphyEl = document.getElementById('processedCalligraphy');
        const cropContainer = document.getElementById('cropContainer');
        const compositePreview = document.getElementById('compositePreview');
        const compositeBackground = document.getElementById('compositeBackground');
        const compositeCalligraphy = document.getElementById('compositeCalligraphy');
        const calligraphyOverlay = document.getElementById('calligraphyOverlay');
        const scaleSlider = document.getElementById('scaleSlider');
        const rotationSlider = document.getElementById('rotationSlider');
        const scaleValue = document.getElementById('scaleValue');
        const rotationValue = document.getElementById('rotationValue');
        const multiplyMode = document.getElementById('multiplyMode');
        const screenMode = document.getElementById('screenMode');
        const customModal = document.getElementById('customModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalConfirm = document.getElementById('modalConfirm');
        const modalCancel = document.getElementById('modalCancel');
        
        // 이미지 압축 함수
        function compressImage(file, maxWidth = 1200, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
                    canvas.width = img.width * ratio;
                    canvas.height = img.height * ratio;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    canvas.toBlob(resolve, 'image/jpeg', quality);
                };
                
                img.src = URL.createObjectURL(file);
            });
        }
        
        // 이미지 자동 보정 함수 (흑백, 대비 100%)
        function processCalligraphyImage(imageData) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // 원본 이미지 그리기
                    ctx.drawImage(img, 0, 0);
                    
                    // 이미지 데이터 가져오기
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // 흑백 변환 및 대비 조정
                    for (let i = 0; i < data.length; i += 4) {
                        // 그레이스케일 계산
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        
                        // 대비 100% 적용 (0 또는 255)
                        const contrast = gray > 128 ? 255 : 0;
                        
                        data[i] = contrast;     // R
                        data[i + 1] = contrast; // G
                        data[i + 2] = contrast; // B
                        // data[i + 3]는 alpha 채널이므로 그대로 유지
                    }
                    
                    // 처리된 이미지 데이터 적용
                    ctx.putImageData(imageData, 0, 0);
                    
                    // 결과를 Blob으로 변환
                    canvas.toBlob(resolve, 'image/png');
                };
                
                img.src = imageData;
            });
        }
        
        // 모달 표시 함수
        function showModal(title, message, showCancel = false) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalCancel.style.display = showCancel ? 'inline-block' : 'none';
            customModal.style.display = 'flex';
        }
        
        // 모달 닫기 함수
        function closeModal() {
            customModal.style.display = 'none';
        }
        
        // 뒤로가기 함수
        function goBack() {
            if (currentStep > 1) {
                currentStep--;
                showStep(currentStep);
                
                // 2단계에서 1단계로 갈 때 업로드 영역 다시 표시
                if (currentStep === 1) {
                    const uploadAreas = document.querySelectorAll('.file-upload-area');
                    uploadAreas.forEach(area => {
                        area.style.display = 'block';
                    });
                    const previews = document.querySelectorAll('#backgroundPreview, #calligraphyPreview');
                    previews.forEach(preview => {
                        preview.style.display = 'none';
                    });
                }
            }
        }
        
        // 단계 표시 함수
        function showStep(step) {
            steps.forEach((s, index) => {
                s.classList.toggle('active', index + 1 === step);
            });
            
            // 모든 단계의 점들 업데이트
            document.querySelectorAll('.step-indicator').forEach(stepIndicator => {
                const dots = stepIndicator.querySelectorAll('.step-dot');
                dots.forEach((dot, index) => {
                    // 모든 클래스 제거
                    dot.classList.remove('active', 'completed');
                    
                    // 현재 단계만 active (흰색), 나머지는 기본 상태 (흰색 투명도 50%)
                    if (index + 1 === step) {
                        dot.classList.add('active');
                    }
                });
            });
            
            // 뒤로가기 버튼 표시/숨김
            document.querySelector('.back-button').style.display = step > 1 ? 'block' : 'none';
            
            // 각 단계별 초기화
            if (step === 3) {
                // 크롭 영역 초기화
                setTimeout(() => {
                    initCropArea();
                }, 100);
            } else if (step === 4) {
                updateCompositePreview();
            }
        }
        
        // 다음 단계로 이동
        function nextStep() {
            if (currentStep < 4) {
                currentStep++;
                showStep(currentStep);
            }
        }
        
        // 이전 단계로 이동
        function prevStep() {
            if (currentStep > 1) {
                currentStep--;
                showStep(currentStep);
            }
        }
        
        // 새로운 정확한 이미지 크롭 시스템
        class PreciseCropSystem {
            constructor() {
                this.cropArea = { x: 10, y: 10, width: 80, height: 80 };
                this.isDragging = false;
                this.isResizing = false;
                this.resizeHandle = null;
                this.startPos = { x: 0, y: 0 };
                this.startCropArea = { x: 0, y: 0, width: 0, height: 0 };
            }

            // 이미지의 실제 표시 영역 계산 (CSS object-fit: contain 고려)
            getImageDisplayBounds(imgElement) {
                const imgRect = imgElement.getBoundingClientRect();
                
                // CSS object-fit: contain으로 인한 실제 이미지 영역 계산
                const imgAspectRatio = imgElement.naturalWidth / imgElement.naturalHeight;
                const containerAspectRatio = imgRect.width / imgRect.height;
                
                let actualWidth, actualHeight, offsetX, offsetY;
                
                if (containerAspectRatio > imgAspectRatio) {
                    // 컨테이너가 더 넓음 - 이미지가 세로로 맞춰짐
                    actualHeight = imgRect.height;
                    actualWidth = imgRect.height * imgAspectRatio;
                    offsetX = (imgRect.width - actualWidth) / 2;
                    offsetY = 0;
                } else {
                    // 컨테이너가 더 높음 - 이미지가 가로로 맞춰짐
                    actualWidth = imgRect.width;
                    actualHeight = imgRect.width / imgAspectRatio;
                    offsetX = 0;
                    offsetY = (imgRect.height - actualHeight) / 2;
                }
                
                const bounds = {
                    x: imgRect.left + offsetX,
                    y: imgRect.top + offsetY,
                    width: actualWidth,
                    height: actualHeight,
                    offsetX,
                    offsetY,
                    // 추가 정보: 원본 이미지 크기와 컨테이너 크기
                    originalWidth: imgElement.naturalWidth,
                    originalHeight: imgElement.naturalHeight,
                    containerWidth: imgRect.width,
                    containerHeight: imgRect.height,
                    aspectRatio: imgAspectRatio,
                    containerAspectRatio: containerAspectRatio
                };
                
                console.log('이미지 표시 영역 (개선됨):', bounds);
                return bounds;
            }

            // 픽셀 좌표를 원본 이미지 좌표로 변환
            pixelToImageCoords(pixelX, pixelY, imgElement, displayBounds) {
                const scaleX = imgElement.naturalWidth / displayBounds.width;
                const scaleY = imgElement.naturalHeight / displayBounds.height;
                
                const imageX = (pixelX - displayBounds.x) * scaleX;
                const imageY = (pixelY - displayBounds.y) * scaleY;
                
                return { x: imageX, y: imageY };
            }

            // 원본 이미지 좌표를 픽셀 좌표로 변환
            imageToPixelCoords(imageX, imageY, imgElement, displayBounds) {
                const scaleX = displayBounds.width / imgElement.naturalWidth;
                const scaleY = displayBounds.height / imgElement.naturalHeight;
                
                const pixelX = displayBounds.x + imageX * scaleX;
                const pixelY = displayBounds.y + imageY * scaleY;
                
                return { x: pixelX, y: pixelY };
            }

            // 정확한 이미지 크롭
            async cropImage(imageData, cropArea) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = () => {
                        const displayImg = document.getElementById('processedCalligraphy');
                        const displayBounds = this.getImageDisplayBounds(displayImg);
                        
                        // 크롭 영역을 픽셀 좌표로 변환
                        const cropX = (cropArea.x / 100) * displayBounds.width;
                        const cropY = (cropArea.y / 100) * displayBounds.height;
                        const cropWidth = (cropArea.width / 100) * displayBounds.width;
                        const cropHeight = (cropArea.height / 100) * displayBounds.height;
                        
                        // 원본 이미지 좌표로 변환
                        const sourceCoords = this.pixelToImageCoords(
                            displayBounds.x + cropX, 
                            displayBounds.y + cropY, 
                            img, 
                            displayBounds
                        );
                        
                        const sourceEndCoords = this.pixelToImageCoords(
                            displayBounds.x + cropX + cropWidth, 
                            displayBounds.y + cropY + cropHeight, 
                            img, 
                            displayBounds
                        );
                        
                        const sourceX = Math.max(0, Math.min(img.naturalWidth, sourceCoords.x));
                        const sourceY = Math.max(0, Math.min(img.naturalHeight, sourceCoords.y));
                        const sourceWidth = Math.max(1, Math.min(img.naturalWidth - sourceX, sourceEndCoords.x - sourceX));
                        const sourceHeight = Math.max(1, Math.min(img.naturalHeight - sourceY, sourceEndCoords.y - sourceY));
                        
                        // 크롭된 이미지 크기 설정
                        canvas.width = sourceWidth;
                        canvas.height = sourceHeight;
                        
                        // 이미지 크롭
                        ctx.drawImage(
                            img,
                            sourceX, sourceY, sourceWidth, sourceHeight,
                            0, 0, sourceWidth, sourceHeight
                        );
                        
                        console.log('정확한 크롭 정보:', {
                            cropArea,
                            displayBounds,
                            sourceCoords: { x: sourceX, y: sourceY, width: sourceWidth, height: sourceHeight },
                            originalSize: { width: img.naturalWidth, height: img.naturalHeight }
                        });
                        
                        canvas.toBlob(resolve, 'image/png');
                    };
                    
                    img.src = imageData;
                });
            }

            // 크롭 핸들 업데이트
            updateCropHandles(cropAreaEl = null) {
                const img = document.getElementById('processedCalligraphy');
                if (!cropAreaEl) {
                    cropAreaEl = document.getElementById('cropArea');
                }
                
                if (!img || !cropAreaEl) {
                    console.log('이미지 또는 크롭 영역 요소를 찾을 수 없음');
                    return;
                }
                
                const displayBounds = this.getImageDisplayBounds(img);
                
                // 크롭 영역을 이미지 컨테이너 기준 상대 좌표로 변환
                const imgContainer = img.parentElement;
                const containerRect = imgContainer.getBoundingClientRect();
                
                // 이미지 컨테이너 내에서의 상대 위치 계산 (이미지의 실제 표시 영역 기준)
                const imageOffsetX = displayBounds.x - containerRect.left;
                const imageOffsetY = displayBounds.y - containerRect.top;
                
                const relativeX = imageOffsetX + (this.cropArea.x / 100) * displayBounds.width;
                const relativeY = imageOffsetY + (this.cropArea.y / 100) * displayBounds.height;
                const width = (this.cropArea.width / 100) * displayBounds.width;
                const height = (this.cropArea.height / 100) * displayBounds.height;
                
                console.log('크롭 영역 업데이트:', {
                    cropArea: this.cropArea,
                    relativeCoords: { x: relativeX, y: relativeY, width, height },
                    displayBounds,
                    containerRect,
                    imageOffset: { x: imageOffsetX, y: imageOffsetY }
                });
                
                // 크롭 영역이 올바른 위치에 있는지 확인
                console.log('크롭 영역 요소:', cropAreaEl);
                console.log('크롭 영역 스타일:', {
                    left: cropAreaEl.style.left,
                    top: cropAreaEl.style.top,
                    width: cropAreaEl.style.width,
                    height: cropAreaEl.style.height
                });
                
                // 크롭 영역 업데이트 (상대 좌표 사용)
                cropAreaEl.style.left = relativeX + 'px';
                cropAreaEl.style.top = relativeY + 'px';
                cropAreaEl.style.width = width + 'px';
                cropAreaEl.style.height = height + 'px';
                
                // 핸들 위치 업데이트 (기존 핸들 완전 제거 후 새로 생성)
                this.updateHandles(cropAreaEl);
            }

            // 핸들 위치 업데이트 (크롭 사각형에 정확히 붙이기)
            updateHandles(cropAreaEl) {
                console.log('핸들 업데이트 시작 - 기존 핸들 제거');
                
                // 기존 핸들 완전 제거
                const existingHandles = cropAreaEl.querySelectorAll('.crop-handle');
                console.log(`제거할 핸들 개수: ${existingHandles.length}`);
                existingHandles.forEach(handle => {
                    handle.remove();
                });
                
                // 즉시 핸들 생성 (디바운싱 없이)
                console.log('새 핸들 생성 시작');
                
                // 8개 핸들 동적 생성
                const directions = ['nw', 'ne', 'sw', 'se', 'n', 's', 'w', 'e'];
                directions.forEach(direction => {
                    const handle = document.createElement('div');
                    handle.className = `crop-handle ${direction}`;
                    handle.dataset.direction = direction;
                    cropAreaEl.appendChild(handle);
                });
                
                console.log('새 핸들 생성 완료');
                
                // 새로 생성된 핸들에 이벤트 리스너 추가
                const newHandles = cropAreaEl.querySelectorAll('.crop-handle');
                this.setupHandleEvents(newHandles);
                
                // 새로 생성된 핸들 위치 설정
                console.log(`새로 생성된 핸들 개수: ${newHandles.length}`);
                newHandles.forEach(handle => {
                        const direction = handle.dataset.direction;
                        
                        // 모든 핸들의 기본 스타일 초기화
                        handle.style.left = 'auto';
                        handle.style.right = 'auto';
                        handle.style.top = 'auto';
                        handle.style.bottom = 'auto';
                        handle.style.transform = 'none';
                        
                        switch(direction) {
                            case 'nw':
                                handle.style.left = '-10px';
                                handle.style.top = '-10px';
                                break;
                            case 'ne':
                                handle.style.right = '-10px';
                                handle.style.top = '-10px';
                                break;
                            case 'sw':
                                handle.style.left = '-10px';
                                handle.style.bottom = '-10px';
                                break;
                            case 'se':
                                handle.style.right = '-10px';
                                handle.style.bottom = '-10px';
                                break;
                            case 'n':
                                handle.style.left = '50%';
                                handle.style.top = '-10px';
                                handle.style.transform = 'translateX(-50%)';
                                break;
                            case 's':
                                handle.style.left = '50%';
                                handle.style.bottom = '-10px';
                                handle.style.transform = 'translateX(-50%)';
                                break;
                            case 'w':
                                handle.style.left = '-10px';
                                handle.style.top = '50%';
                                handle.style.transform = 'translateY(-50%)';
                                break;
                            case 'e':
                                handle.style.right = '-10px';
                                handle.style.top = '50%';
                                handle.style.transform = 'translateY(-50%)';
                                break;
                        }
                    });
                    
                    console.log('핸들 위치 설정 완료');
            }
            
            // 핸들 이벤트 설정 (마우스 + 터치)
            setupHandleEvents(handles) {
                const img = document.getElementById('processedCalligraphy');
                console.log('핸들 이벤트 설정 시작, 핸들 개수:', handles.length);
                
                handles.forEach(handle => {
                    console.log('핸들 이벤트 추가:', handle.dataset.direction);
                    // 마우스 이벤트
                    handle.addEventListener('mousedown', (e) => {
                        console.log('크롭 핸들 드래그 시작:', handle.dataset.direction);
                        this.isResizing = true;
                        this.resizeHandle = handle.dataset.direction;
                        this.startPos = { x: e.clientX, y: e.clientY };
                        this.startCropArea = { ...this.cropArea };
                        e.preventDefault();
                        e.stopPropagation();
                    });

                    // 터치 이벤트 (모바일 최적화)
                    handle.addEventListener('touchstart', (e) => {
                        console.log('크롭 핸들 터치 시작:', handle.dataset.direction);
                        this.isResizing = true;
                        this.resizeHandle = handle.dataset.direction;
                        const touch = e.touches[0];
                        // 터치 좌표를 더 정확하게 저장
                        this.startPos = { 
                            x: touch.clientX, 
                            y: touch.clientY,
                            pageX: touch.pageX,
                            pageY: touch.pageY
                        };
                        this.startCropArea = { ...this.cropArea };
                        // 모바일에서는 즉시 움직임 허용
                        this.minMoveDistance = 0; // 모바일에서는 즉시 반응
                        this.hasMoved = true; // 이미 움직인 것으로 간주
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
            }
        }

        // 전역 크롭 시스템 인스턴스
        const cropSystem = new PreciseCropSystem();
        
        // 터치 성능 최적화를 위한 디바운싱 변수
        let touchUpdateTimeout = null;
        
        // 합성 미리보기 업데이트
        function updateCompositePreview() {
            if (!backgroundImage) return;
            
            const compositeBackground = document.getElementById('compositeBackground');
            const compositeCalligraphy = document.getElementById('compositeCalligraphy');
            
            if (compositeBackground) {
                compositeBackground.src = backgroundImage;
                
                // 배경 이미지 로드 후 비율에 따라 조정
                compositeBackground.onload = () => {
                    adjustBackgroundImageSize(compositeBackground);
                };
            }
            
            if (compositeCalligraphy) {
                // 크롭된 이미지가 있으면 사용, 없으면 원본 이미지 사용
                if (croppedCalligraphy) {
                    console.log('크롭된 이미지 사용:', croppedCalligraphy);
                    compositeCalligraphy.src = croppedCalligraphy;
                } else if (calligraphyImage) {
                    console.log('원본 이미지 사용:', calligraphyImage);
                    compositeCalligraphy.src = calligraphyImage;
                }
                
                compositeCalligraphy.onload = () => {
                    setTimeout(() => {
                        updateEditHandles();
                    }, 100);
                };
            }
            
            compositeSystem.updatePreview();
        }
        
        // 배경 이미지 크기 자동 조정 함수 (크롭과 합성에서 동일한 방식 적용)
        function adjustBackgroundImageSize(imgElement) {
            const container = imgElement.parentElement;
            const containerRect = container.getBoundingClientRect();
            
            // 컨테이너의 가로세로 비율
            const containerAspectRatio = containerRect.width / containerRect.height;
            // 이미지의 가로세로 비율
            const imageAspectRatio = imgElement.naturalWidth / imgElement.naturalHeight;
            
            console.log('비율 비교:', {
                container: containerAspectRatio,
                image: imageAspectRatio,
                containerSize: { width: containerRect.width, height: containerRect.height },
                imageSize: { width: imgElement.naturalWidth, height: imgElement.naturalHeight }
            });
            
            // 모든 경우에 object-fit: contain을 사용하여 일관성 보장
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.maxWidth = '100%';
            imgElement.style.maxHeight = '100%';
            imgElement.style.objectFit = 'contain';
            imgElement.style.objectPosition = 'center';
            
            console.log('일관된 이미지 표시 방식 적용 - object-fit: contain');
        }
        
        // 글씨 이미지의 실제 자른 모양 감지하여 라인 생성 (calligraphyOverlay 기준)
        function createCropOutline() {
            // 기존 크롭 아웃라인 제거
            const existingOutline = document.querySelector('.crop-outline');
            if (existingOutline) {
                existingOutline.remove();
            }
            
            // calligraphyOverlay와 동일한 크기로 아웃라인 생성
            const calligraphyOverlay = document.getElementById('calligraphyOverlay');
            if (!calligraphyOverlay) return;
            
            const outline = document.createElement('div');
            outline.className = 'crop-outline';
            
            // calligraphyOverlay의 위치와 크기를 그대로 사용
            const overlayRect = calligraphyOverlay.getBoundingClientRect();
            const previewRect = document.getElementById('compositePreview').getBoundingClientRect();
            
            const relativeLeft = overlayRect.left - previewRect.left;
            const relativeTop = overlayRect.top - previewRect.top;
            
            outline.style.left = relativeLeft + 'px';
            outline.style.top = relativeTop + 'px';
            outline.style.width = overlayRect.width + 'px';
            outline.style.height = overlayRect.height + 'px';
            
            // calligraphyOverlay와 동일한 transform 적용
            const overlayTransform = calligraphyOverlay.style.transform;
            if (overlayTransform) {
                outline.style.transform = overlayTransform;
            }
            
            // composite-preview에 추가
            document.getElementById('compositePreview').appendChild(outline);
            
            console.log('크롭 아웃라인 생성 (calligraphyOverlay 기준):', {
                left: relativeLeft,
                top: relativeTop,
                width: overlayRect.width,
                height: overlayRect.height,
                transform: overlayTransform
            });
        }
        
        // 크롭된 이미지의 실제 내용 영역 감지
        function detectContentBounds(imageSrc) {
            return new Promise((resolve) => {
                if (!imageSrc) {
                    resolve({ x: 0, y: 0, width: 100, height: 100 });
                    return;
                }
                
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 원본 이미지 크기로 캔버스 설정
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    
                    // 이미지를 캔버스에 그리기
                    ctx.drawImage(img, 0, 0);
                    
                    // 이미지 데이터 분석
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
                    let hasContent = false;
                    
                    // 투명도 임계값 설정 (완전히 투명하지 않은 픽셀)
                    const alphaThreshold = 20; // 덜 민감하게 설정하여 전체 영역 포함
                    
                    // 성능을 위해 스캔 간격 조정 (모든 픽셀을 확인하지 않고 샘플링)
                    const scanStep = Math.max(1, Math.floor(Math.min(canvas.width, canvas.height) / 100)); // 덜 세밀하게 스캔
                    
                    console.log(`이미지 크기: ${canvas.width}x${canvas.height}, 스캔 간격: ${scanStep}`);
                    
                    for (let y = 0; y < canvas.height; y += scanStep) {
                        for (let x = 0; x < canvas.width; x += scanStep) {
                            const index = (y * canvas.width + x) * 4;
                            const alpha = data[index + 3];
                            
                            if (alpha > alphaThreshold) {
                                hasContent = true;
                                minX = Math.min(minX, x);
                                minY = Math.min(minY, y);
                                maxX = Math.max(maxX, x);
                                maxY = Math.max(maxY, y);
                            }
                        }
                    }
                    
                    if (!hasContent) {
                        console.log('크롭된 이미지에서 내용을 찾을 수 없음');
                        resolve({ x: 0, y: 0, width: 100, height: 100 });
                        return;
                    }
                    
                    // 경계를 약간 확장하여 여백 추가 (더 관대한 여백 계산)
                    const padding = Math.max(2, Math.floor(Math.min(canvas.width, canvas.height) / 50)); // 더 큰 여백
                    minX = Math.max(0, minX - padding);
                    minY = Math.max(0, minY - padding);
                    maxX = Math.min(canvas.width, maxX + padding);
                    maxY = Math.min(canvas.height, maxY + padding);
                    
                    // 최소 크기 보장 (너무 작으면 확장)
                    const minSize = Math.min(canvas.width, canvas.height) / 10; // 더 큰 최소 크기
                    if (maxX - minX < minSize) {
                        const centerX = (minX + maxX) / 2;
                        minX = Math.max(0, centerX - minSize / 2);
                        maxX = Math.min(canvas.width, centerX + minSize / 2);
                    }
                    if (maxY - minY < minSize) {
                        const centerY = (minY + maxY) / 2;
                        minY = Math.max(0, centerY - minSize / 2);
                        maxY = Math.min(canvas.height, centerY + minSize / 2);
                    }
                    
                    // 픽셀 좌표를 퍼센트로 변환
                    const bounds = {
                        x: (minX / canvas.width) * 100,
                        y: (minY / canvas.height) * 100,
                        width: ((maxX - minX) / canvas.width) * 100,
                        height: ((maxY - minY) / canvas.height) * 100,
                        pixelBounds: { minX, minY, maxX, maxY },
                        originalSize: { width: canvas.width, height: canvas.height }
                    };
                    
                    console.log('정확한 크롭된 이미지 영역 감지:', bounds);
                    console.log('픽셀 경계:', bounds.pixelBounds);
                    console.log('원본 이미지 크기:', bounds.originalSize);
                    resolve(bounds);
                };
                img.src = imageSrc;
            });
        }
        
        // 편집 핸들을 크롭된 이미지 내용과 실시간 동기화 (반응형 개선)
        function syncEditHandlesWithContent() {
            const editHandles = document.getElementById('editHandles');
            const calligraphyOverlay = document.getElementById('calligraphyOverlay');
            const compositePreview = document.getElementById('compositePreview');
            
            if (!editHandles || !calligraphyOverlay || !compositePreview || !croppedCalligraphy) return;
            
            // 크롭된 이미지 내용 영역 다시 계산
            detectContentBounds(croppedCalligraphy).then((bounds) => {
                // calligraphyOverlay의 현재 위치와 크기 (compositePreview 기준)
                const overlayRect = calligraphyOverlay.getBoundingClientRect();
                const previewRect = compositePreview.getBoundingClientRect();
                
                // 디버깅 영역과 정확히 동일한 위치에 편집 핸들 배치
                const contentXPercent = bounds.x;
                const contentYPercent = bounds.y;
                const contentWidthPercent = bounds.width;
                const contentHeightPercent = bounds.height;
                
                console.log('편집 핸들 위치 계산 (디버깅 영역과 동일):', {
                    contentBounds: bounds,
                    position: { left: contentXPercent, top: contentYPercent, width: contentWidthPercent, height: contentHeightPercent }
                });
                
                // 편집 핸들 위치와 크기 설정 (크롭된 이미지 내용에 맞춰)
                editHandles.style.position = 'absolute';
                editHandles.style.left = `${contentXPercent}%`;
                editHandles.style.top = `${contentYPercent}%`;
                editHandles.style.width = `${contentWidthPercent}%`;
                editHandles.style.height = `${contentHeightPercent}%`;
                editHandles.style.margin = '0';
                editHandles.style.padding = '0';
                editHandles.style.transform = 'none';
                editHandles.style.transformOrigin = 'center';
                editHandles.style.display = 'block';
                editHandles.style.opacity = '1';
                editHandles.style.visibility = 'visible';
                editHandles.style.pointerEvents = 'auto';
                editHandles.style.zIndex = '10';
                
                // 편집 핸들이 이미 calligraphyOverlay의 자식으로 올바르게 위치함
                console.log('편집 핸들 부모 확인:', editHandles.parentNode?.id);
                
                // 편집 핸들 DOM 구조 디버깅
                console.log('편집 핸들 DOM 구조:', {
                    parentNode: editHandles.parentNode?.id || editHandles.parentNode?.tagName,
                    position: editHandles.style.position,
                    left: editHandles.style.left,
                    top: editHandles.style.top,
                    width: editHandles.style.width,
                    height: editHandles.style.height,
                    zIndex: editHandles.style.zIndex,
                    opacity: editHandles.style.opacity,
                    visibility: editHandles.style.visibility
                });
                
                console.log('편집 핸들 calligraphyOverlay 기준 동기화 완료:', {
                    contentBounds: bounds,
                    position: { left: contentXPercent, top: contentYPercent, width: contentWidthPercent, height: contentHeightPercent },
                    parentTransform: calligraphyOverlay.style.transform
                });
                
                // 디버깅 영역 생성 비활성화 (사용자 요청에 따라 제거)
            });
        }
        
        // 편집 핸들 위치 업데이트 (compositePreview 내부에 위치)
        function updateEditHandles() {
            const editHandles = document.getElementById('editHandles');
            const calligraphyOverlay = document.getElementById('calligraphyOverlay');
            if (!editHandles || !calligraphyOverlay) return;
            
            console.log('편집 핸들 업데이트 시작 - calligraphyOverlay 내부');
            
            // 편집 핸들을 calligraphyOverlay와 동일하게 설정
            editHandles.style.position = 'absolute';
            editHandles.style.left = calligraphyOverlay.style.left || '0%';
            editHandles.style.top = calligraphyOverlay.style.top || '0%';
            editHandles.style.width = calligraphyOverlay.style.width || '100%';
            editHandles.style.height = calligraphyOverlay.style.height || '100%';
            editHandles.style.transform = calligraphyOverlay.style.transform || 'none';
            editHandles.style.display = 'block';
            editHandles.style.opacity = '1';
            editHandles.style.visibility = 'visible';
            editHandles.style.pointerEvents = 'auto';
            editHandles.style.zIndex = '10';
            
            console.log('편집 핸들 위치 설정 완료:', {
                left: editHandles.style.left,
                top: editHandles.style.top,
                width: editHandles.style.width,
                height: editHandles.style.height,
                transform: editHandles.style.transform
            });
            
            // 실시간 위치 동기화를 위한 MutationObserver 설정
            if (!window.editHandlesObserver) {
                window.editHandlesObserver = new MutationObserver(() => {
                    syncEditHandlesWithContent();
                });
                
                // calligraphyOverlay의 스타일 변화 감지
                window.editHandlesObserver.observe(calligraphyOverlay, {
                    attributes: true,
                    attributeFilter: ['style']
                });
            }
            
            // ResizeObserver를 사용하여 더 정확한 크기 변화 감지
            if (!window.editHandlesResizeObserver) {
                let resizeTimeout;
                window.editHandlesResizeObserver = new ResizeObserver(() => {
                    // 디바운싱으로 성능 최적화
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        syncEditHandlesWithContent();
                    }, 16); // 60fps에 맞춰 16ms 간격
                });
                
                // compositePreview와 calligraphyOverlay 크기 변화 감지
                const compositePreview = document.getElementById('compositePreview');
                if (compositePreview) {
                    window.editHandlesResizeObserver.observe(compositePreview);
                }
                window.editHandlesResizeObserver.observe(calligraphyOverlay);
            }
            
            // 크롭된 이미지가 있으면 syncEditHandlesWithContent로 정확한 위치 설정
            if (croppedCalligraphy) {
                setTimeout(() => {
                    syncEditHandlesWithContent();
                }, 100);
            }
            
            // 핸들 위치 조정 (고정 크기 유지)
            const scaleHandle = document.getElementById('scaleHandle');
            const rotateHandle = document.getElementById('rotateHandle');
            
            if (scaleHandle) {
                scaleHandle.style.right = '-20px';
                scaleHandle.style.bottom = '-20px';
                scaleHandle.style.width = '40px !important';
                scaleHandle.style.height = '40px !important';
                scaleHandle.style.minWidth = '40px !important';
                scaleHandle.style.minHeight = '40px !important';
                scaleHandle.style.maxWidth = '40px !important';
                scaleHandle.style.maxHeight = '40px !important';
                scaleHandle.style.transform = 'none !important';
            }
            
            if (rotateHandle) {
                rotateHandle.style.right = '-20px';
                rotateHandle.style.top = '-20px';
                rotateHandle.style.width = '40px !important';
                rotateHandle.style.height = '40px !important';
                rotateHandle.style.minWidth = '40px !important';
                rotateHandle.style.minHeight = '40px !important';
                rotateHandle.style.maxWidth = '40px !important';
                rotateHandle.style.maxHeight = '40px !important';
                rotateHandle.style.transform = 'none !important';
            }
            
            console.log('편집 핸들 업데이트 완료 - compositePreview 내부에 위치');
        }
        
        
        // 새로운 정확한 합성 시스템
        class PreciseCompositeSystem {
            constructor() {
                this.position = { x: 50, y: 50 }; // 퍼센트 단위
                this.scale = 0.3; // 배경의 30% 크기로 시작 (더 작게)
                this.rotation = 0;
                this.blendMode = 'multiply';
                this.bounds = { x: 0, y: 0, width: 100, height: 100 }; // 글씨의 실제 경계
                this.backgroundDisplayBounds = null; // 배경 이미지의 실제 표시 영역
            }

            // 배경 이미지의 실제 표시 영역 계산 (크롭 시스템과 동일한 방식)
            getBackgroundDisplayBounds(imgElement) {
                const imgRect = imgElement.getBoundingClientRect();
                
                // CSS object-fit: contain으로 인한 실제 이미지 영역 계산
                const imgAspectRatio = imgElement.naturalWidth / imgElement.naturalHeight;
                const containerAspectRatio = imgRect.width / imgRect.height;
                
                let actualWidth, actualHeight, offsetX, offsetY;
                
                if (containerAspectRatio > imgAspectRatio) {
                    // 컨테이너가 더 넓음 - 이미지가 세로로 맞춰짐
                    actualHeight = imgRect.height;
                    actualWidth = imgRect.height * imgAspectRatio;
                    offsetX = (imgRect.width - actualWidth) / 2;
                    offsetY = 0;
                } else {
                    // 컨테이너가 더 높음 - 이미지가 가로로 맞춰짐
                    actualWidth = imgRect.width;
                    actualHeight = imgRect.width / imgAspectRatio;
                    offsetX = 0;
                    offsetY = (imgRect.height - actualHeight) / 2;
                }
                
                const bounds = {
                    x: imgRect.left + offsetX,
                    y: imgRect.top + offsetY,
                    width: actualWidth,
                    height: actualHeight,
                    offsetX,
                    offsetY,
                    originalWidth: imgElement.naturalWidth,
                    originalHeight: imgElement.naturalHeight,
                    containerWidth: imgRect.width,
                    containerHeight: imgRect.height,
                    aspectRatio: imgAspectRatio,
                    containerAspectRatio: containerAspectRatio
                };
                
                console.log('배경 이미지 표시 영역:', bounds);
                return bounds;
            }

            // 잘라진 이미지의 실제 경계 감지
            detectImageBounds() {
                return new Promise((resolve) => {
                    if (!croppedCalligraphy) {
                        this.bounds = { x: 0, y: 0, width: 100, height: 100 };
                        resolve(this.bounds);
                        return;
                    }
                    
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        
                        ctx.drawImage(img, 0, 0);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
                        let hasContent = false;
                        
                        // 픽셀을 스캔하여 실제 내용이 있는 영역 찾기
                        for (let y = 0; y < canvas.height; y++) {
                            for (let x = 0; x < canvas.width; x++) {
                                const index = (y * canvas.width + x) * 4;
                                const alpha = data[index + 3];
                                
                                if (alpha > 0) { // 투명하지 않은 픽셀
                                    hasContent = true;
                                    minX = Math.min(minX, x);
                                    minY = Math.min(minY, y);
                                    maxX = Math.max(maxX, x);
                                    maxY = Math.max(maxY, y);
                                }
                            }
                        }
                        
                        if (hasContent) {
                            // 퍼센트로 변환
                            this.bounds = {
                                x: (minX / canvas.width) * 100,
                                y: (minY / canvas.height) * 100,
                                width: ((maxX - minX) / canvas.width) * 100,
                                height: ((maxY - minY) / canvas.height) * 100
                            };
                        } else {
                            this.bounds = { x: 0, y: 0, width: 100, height: 100 };
                        }
                        
                        console.log('잘라진 이미지 경계 감지:', this.bounds);
                        resolve(this.bounds);
                    };
                    img.src = croppedCalligraphy;
                });
            }

            // 배경 이미지의 실제 표시 영역에 맞춰 글씨 이미지 크기 조정
            adjustCalligraphyToBackground() {
                if (!this.backgroundDisplayBounds || !croppedCalligraphy) return;
                
                const calligraphyOverlay = document.getElementById('calligraphyOverlay');
                if (!calligraphyOverlay) return;
                
                // 배경 이미지의 실제 표시 영역 비율 계산
                const backgroundRatio = this.backgroundDisplayBounds.width / this.backgroundDisplayBounds.height;
                
                // 크롭된 이미지의 비율 계산
                const img = new Image();
                img.onload = () => {
                    const calligraphyRatio = img.naturalWidth / img.naturalHeight;
                    
                    console.log('비율 비교:', {
                        background: backgroundRatio,
                        calligraphy: calligraphyRatio,
                        backgroundBounds: this.backgroundDisplayBounds
                    });
                    
                    // 배경 이미지의 실제 표시 영역에 맞춰 글씨 오버레이 크기 조정
                    if (backgroundRatio > calligraphyRatio) {
                        // 배경이 더 넓음 - 글씨를 세로로 맞춤
                        calligraphyOverlay.style.width = 'auto';
                        calligraphyOverlay.style.height = '100%';
                        calligraphyOverlay.style.maxWidth = '100%';
                        calligraphyOverlay.style.maxHeight = '100%';
                    } else {
                        // 배경이 더 높음 - 글씨를 가로로 맞춤
                        calligraphyOverlay.style.width = '100%';
                        calligraphyOverlay.style.height = 'auto';
                        calligraphyOverlay.style.maxWidth = '100%';
                        calligraphyOverlay.style.maxHeight = '100%';
                    }
                    
                    calligraphyOverlay.style.objectFit = 'contain';
                    calligraphyOverlay.style.objectPosition = 'center';
                    
                    console.log('글씨 이미지 크기 조정 완료');
                };
                img.src = croppedCalligraphy;
            }

            // 미리보기 업데이트 (CSS Transform 사용)
            updatePreview() {
                if (!backgroundImage) return;
                
                const compositeBackground = document.getElementById('compositeBackground');
                const compositeCalligraphy = document.getElementById('compositeCalligraphy');
                const calligraphyOverlay = document.getElementById('calligraphyOverlay');
                const editHandles = document.getElementById('editHandles');
                
                if (!compositeBackground || !compositeCalligraphy || !calligraphyOverlay) return;
                
                compositeBackground.src = backgroundImage;
                
                // 배경 이미지 로드 후 비율에 따라 조정
                compositeBackground.onload = () => {
                    adjustBackgroundImageSize(compositeBackground);
                    // 배경 이미지의 실제 표시 영역 계산 및 저장
                    this.backgroundDisplayBounds = this.getBackgroundDisplayBounds(compositeBackground);
                };
                
                // 크롭된 이미지가 있으면 사용, 없으면 원본 이미지 사용
                if (croppedCalligraphy) {
                    console.log('compositeSystem에서 크롭된 이미지 사용:', croppedCalligraphy);
                    compositeCalligraphy.src = croppedCalligraphy;
                } else if (calligraphyImage) {
                    console.log('compositeSystem에서 원본 이미지 사용:', calligraphyImage);
                    compositeCalligraphy.src = calligraphyImage;
                } else {
                    return;
                }
                
                // 잘라진 이미지 경계 감지
                this.detectImageBounds().then(() => {
                    // 배경 이미지의 실제 표시 영역에 맞춰 글씨 이미지 크기 조정
                    this.adjustCalligraphyToBackground();
                    this.updateEditHandles();
                });
                
                // 위치, 크기, 회전 적용
                const transform = `translate(-50%, -50%) scale(${this.scale}) rotate(${this.rotation}deg)`;
                calligraphyOverlay.style.left = `${this.position.x}%`;
                calligraphyOverlay.style.top = `${this.position.y}%`;
                calligraphyOverlay.style.transform = transform;
                
                // 편집 핸들을 calligraphyOverlay와 정확히 동일한 위치와 크기로 설정
                if (editHandles) {
                    // calligraphyOverlay와 동일한 CSS 속성 적용
                    editHandles.style.left = calligraphyOverlay.style.left;
                    editHandles.style.top = calligraphyOverlay.style.top;
                    editHandles.style.width = calligraphyOverlay.style.width;
                    editHandles.style.height = calligraphyOverlay.style.height;
                    editHandles.style.transform = calligraphyOverlay.style.transform;
                }
                
                console.log('미리보기 업데이트:', {
                    position: this.position,
                    scale: this.scale,
                    rotation: this.rotation,
                    blendMode: this.blendMode,
                    bounds: this.bounds,
                    transform: transform
                });
                
                // 블렌드 모드 적용
                if (this.blendMode === 'screen') {
                    calligraphyOverlay.style.filter = 'invert(1)';
                    calligraphyOverlay.style.mixBlendMode = 'screen';
                } else {
                    calligraphyOverlay.style.filter = 'none';
                    calligraphyOverlay.style.mixBlendMode = 'multiply';
                }
            }
            
            // 편집 핸들 위치 업데이트 (compositePreview 내부에 위치)
            updateEditHandles() {
                const editHandles = document.getElementById('editHandles');
                const calligraphyOverlay = document.getElementById('calligraphyOverlay');
                if (!editHandles || !calligraphyOverlay) return;
                
                console.log('compositeSystem 편집 핸들 업데이트 시작 - compositePreview 내부');
                
                // calligraphyOverlay와 동일한 CSS 속성 적용
                editHandles.style.left = calligraphyOverlay.style.left;
                editHandles.style.top = calligraphyOverlay.style.top;
                editHandles.style.width = calligraphyOverlay.style.width;
                editHandles.style.height = calligraphyOverlay.style.height;
                editHandles.style.transform = calligraphyOverlay.style.transform;
                editHandles.style.display = 'block';
                
                // 크롭된 이미지가 있으면 syncEditHandlesWithContent로 정확한 위치 설정
                if (croppedCalligraphy) {
                    setTimeout(() => {
                        syncEditHandlesWithContent();
                    }, 100);
                }
                
                // 핸들 크기 고정
                const scaleHandle = document.getElementById('scaleHandle');
                const rotateHandle = document.getElementById('rotateHandle');
                
                if (scaleHandle) {
                    scaleHandle.style.width = '40px !important';
                    scaleHandle.style.height = '40px !important';
                    scaleHandle.style.minWidth = '40px !important';
                    scaleHandle.style.minHeight = '40px !important';
                    scaleHandle.style.maxWidth = '40px !important';
                    scaleHandle.style.maxHeight = '40px !important';
                    scaleHandle.style.transform = 'none !important';
                }
                
                if (rotateHandle) {
                    rotateHandle.style.width = '40px !important';
                    rotateHandle.style.height = '40px !important';
                    rotateHandle.style.minWidth = '40px !important';
                    rotateHandle.style.minHeight = '40px !important';
                    rotateHandle.style.maxWidth = '40px !important';
                    rotateHandle.style.maxHeight = '40px !important';
                    rotateHandle.style.transform = 'none !important';
                }
                
                console.log('compositeSystem 편집 핸들 업데이트 완료 - compositePreview 내부에 위치');
            }

            // 정확한 다운로드 이미지 생성 (원본 배경 이미지 크기에 맞춤)
            async downloadImage() {
                return new Promise((resolve) => {
                    // 미리보기 영역의 정확한 크기와 위치 가져오기
                    const previewElement = document.getElementById('compositePreview');
                    const calligraphyOverlay = document.getElementById('calligraphyOverlay');
                    const compositeBackground = document.getElementById('compositeBackground');
                    
                    if (!previewElement || !calligraphyOverlay || !compositeBackground) {
                        console.error('미리보기 요소를 찾을 수 없습니다.');
                        resolve();
                        return;
                    }
                    
                    const previewRect = previewElement.getBoundingClientRect();
                    const overlayRect = calligraphyOverlay.getBoundingClientRect();
                    
                    // 배경 이미지의 실제 표시 영역 계산
                    const backgroundBounds = this.getBackgroundDisplayBounds(compositeBackground);
                    
                    // 원본 배경 이미지 크기로 캔버스 생성
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 배경 이미지 그리기
                    const bgImg = new Image();
                    bgImg.onload = () => {
                        // 원본 배경 이미지 크기로 캔버스 설정
                        canvas.width = bgImg.naturalWidth;
                        canvas.height = bgImg.naturalHeight;
                        
                        // 원본 배경 이미지 그리기 (전체 크기)
                        ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
                        
                        console.log('다운로드 캔버스 크기 (원본 배경 이미지):', {
                            width: canvas.width,
                            height: canvas.height,
                            originalSize: { width: bgImg.naturalWidth, height: bgImg.naturalHeight }
                        });
                        
                        // 글씨 오버레이 그리기
                        const calligraphyImg = new Image();
                        calligraphyImg.onload = () => {
                            ctx.save();
                            
                            // 미리보기에서의 글씨 위치와 크기를 원본 배경 이미지 크기로 변환
                            const scaleX = canvas.width / backgroundBounds.width;
                            const scaleY = canvas.height / backgroundBounds.height;
                            
                            // 미리보기에서의 글씨 중심점을 원본 배경 이미지 좌표로 변환
                            const previewCenterX = overlayRect.left - previewRect.left + overlayRect.width / 2;
                            const previewCenterY = overlayRect.top - previewRect.top + overlayRect.height / 2;
                            
                            // 배경 이미지의 실제 표시 영역 내에서의 상대 위치 계산
                            const relativeX = (previewCenterX - backgroundBounds.offsetX) / backgroundBounds.width;
                            const relativeY = (previewCenterY - backgroundBounds.offsetY) / backgroundBounds.height;
                            
                            // 원본 배경 이미지에서의 실제 위치
                            const centerX = relativeX * canvas.width;
                            const centerY = relativeY * canvas.height;
                            
                            // 글씨 크기를 원본 배경 이미지에 맞게 조정
                            const calligraphyWidth = overlayRect.width * scaleX;
                            const calligraphyHeight = overlayRect.height * scaleY;
                            
                            console.log('다운로드 이미지 생성 (원본 배경 크기):', {
                                canvasSize: { width: canvas.width, height: canvas.height },
                                backgroundBounds: backgroundBounds,
                                scaleFactors: { scaleX, scaleY },
                                previewCenter: { x: previewCenterX, y: previewCenterY },
                                relativePosition: { x: relativeX, y: relativeY },
                                finalCenter: { x: centerX, y: centerY },
                                calligraphySize: { width: calligraphyWidth, height: calligraphyHeight },
                                rotation: this.rotation,
                                blendMode: this.blendMode
                            });
                            
                            // 회전 중심점으로 이동
                            ctx.translate(centerX, centerY);
                            ctx.rotate((this.rotation * Math.PI) / 180);
                            
                            // 블렌드 모드 설정 (미리보기와 동일)
                            if (this.blendMode === 'screen') {
                                ctx.globalCompositeOperation = 'screen';
                                ctx.filter = 'invert(1)';
                            } else {
                                ctx.globalCompositeOperation = 'multiply';
                                ctx.filter = 'none';
                            }
                            
                            // 회전된 이미지의 원본 크기 유지 (늘어남 방지)
                            const originalCalligraphyWidth = calligraphyImg.naturalWidth;
                            const originalCalligraphyHeight = calligraphyImg.naturalHeight;
                            
                            // 스케일 비율 계산 (회전 시 크기 변화 방지)
                            const scaleRatio = Math.min(calligraphyWidth / originalCalligraphyWidth, calligraphyHeight / originalCalligraphyHeight);
                            const finalWidth = originalCalligraphyWidth * scaleRatio;
                            const finalHeight = originalCalligraphyHeight * scaleRatio;
                            
                            // 원본 비율을 유지하며 글씨 그리기 (중심점 기준)
                            ctx.drawImage(calligraphyImg, -finalWidth / 2, -finalHeight / 2, finalWidth, finalHeight);
                            ctx.restore();
                            
                            // 모바일 호환 다운로드
                            const dataURL = canvas.toDataURL('image/jpeg', 0.9);
                            const fileName = 'calligraphy-composite.jpg';
                            
                            // 모바일 감지
                            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                            
                            if (isMobile) {
                                // 모바일에서 갤러리에 바로 저장
                                saveToGallery(canvas, fileName);
                            } else {
                                // 데스크톱에서는 일반 다운로드
                                const link = document.createElement('a');
                                link.download = fileName;
                                link.href = dataURL;
                                link.click();
                            }
                            
                            resolve();
                        };
                        calligraphyImg.src = croppedCalligraphy;
                    };
                    bgImg.src = backgroundImage;
                });
            }

            // 위치 업데이트
            updatePosition(x, y) {
                this.position.x = Math.max(0, Math.min(100, x));
                this.position.y = Math.max(0, Math.min(100, y));
                this.updatePreview();
            }

            // 크기 업데이트
            updateScale(scale) {
                this.scale = Math.max(0.1, Math.min(5, scale));
                this.updatePreview();
                this.updateEditHandles();
            }

            // 회전 업데이트
            updateRotation(rotation) {
                this.rotation = rotation;
                this.updatePreview();
                this.updateEditHandles();
            }

            // 블렌드 모드 업데이트
            updateBlendMode(mode) {
                this.blendMode = mode;
                this.updatePreview();
            }
        }

        // 전역 합성 시스템 인스턴스
        const compositeSystem = new PreciseCompositeSystem();
        
        // 모바일 갤러리 저장 함수
        function saveToGallery(canvas, fileName) {
            // Canvas를 Blob으로 변환
            canvas.toBlob((blob) => {
                if (!blob) {
                    console.error('Canvas를 Blob으로 변환 실패');
                    showSaveErrorModal();
                    return;
                }
                
                // iOS Safari에서 갤러리 저장
                if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                    saveToGalleryIOS(blob, fileName);
                } 
                // Android Chrome에서 갤러리 저장
                else if (/Android/.test(navigator.userAgent)) {
                    saveToGalleryAndroid(blob, fileName);
                } 
                // 기타 모바일 브라우저
                else {
                    saveToGalleryGeneric(blob, fileName);
                }
            }, 'image/jpeg', 0.9);
        }
        
        // iOS Safari 갤러리 저장 (개선된 방법)
        function saveToGalleryIOS(blob, fileName) {
            const url = URL.createObjectURL(blob);
            
            // iOS에서 더 안정적인 저장 방법 사용
            tryAutoSaveIOS(url, fileName);
        }
        
        // iOS 자동 저장 시도 (개선된 버전)
        function tryAutoSaveIOS(url, fileName) {
            console.log('iOS 저장 시도 시작');
            
            // iOS에서는 자동 저장이 제한적이므로 즉시 수동 저장 모달 표시
            showIOSSaveModal(url, fileName);
        }
        
        // iOS 전용 저장 모달 (더 간편한 저장 방법 제공)
        function showIOSSaveModal(dataURL, fileName) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 15px;
                    padding: 30px;
                    max-width: 90%;
                    max-height: 90%;
                    text-align: center;
                    overflow-y: auto;
                ">
                    <h3 style="margin: 0 0 20px 0; color: #333; font-size: 20px; font-weight: bold;">📱 iOS 이미지 저장</h3>
                    <img src="${dataURL}" style="
                        max-width: 100%;
                        max-height: 300px;
                        height: auto;
                        border: 3px solid #007AFF;
                        border-radius: 15px;
                        margin-bottom: 25px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    ">
                    <div style="margin: 25px 0;">
                        <button onclick="downloadImageDirectly('${dataURL}', '${fileName}')" style="
                            background: linear-gradient(135deg, #007AFF, #0056CC);
                            color: white;
                            border: none;
                            padding: 18px 35px;
                            border-radius: 12px;
                            font-size: 17px;
                            font-weight: bold;
                            cursor: pointer;
                            margin: 8px 0;
                            width: 100%;
                            box-shadow: 0 4px 12px rgba(0,122,255,0.3);
                            transition: all 0.2s ease;
                        " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">💾 저장하기</button>
                    </div>
                    <div style="background: #fff3cd; padding: 20px; border-radius: 12px; margin: 20px 0; border-left: 4px solid #ffc107;">
                        <p style="margin: 0 0 15px 0; color: #856404; font-size: 16px; font-weight: bold;">⚠️ iOS 저장 안내:</p>
                        <p style="margin: 0 0 10px 0; color: #856404; font-size: 14px; line-height: 1.5;">
                            <strong>위 버튼이 작동하지 않으면:</strong><br>
                            1️⃣ 이미지를 <strong>길게 누르세요</strong><br>
                            2️⃣ "이미지 저장" 또는 "사진에 저장" 선택<br>
                            3️⃣ 또는 "공유" 버튼으로 갤러리에 저장
                        </p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        padding: 12px 24px;
                        background: #667eea;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 14px;
                        cursor: pointer;
                    ">닫기</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 모달 외부 클릭 시 닫기
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        // 직접 이미지 다운로드 함수 (전역에서 접근 가능하도록)
        window.downloadImageDirectly = function(dataURL, fileName) {
            console.log('직접 다운로드 시도:', fileName);
            
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = fileName;
            link.style.display = 'none';
            document.body.appendChild(link);
            
            try {
                link.click();
                console.log('다운로드 링크 클릭 완료');
                
                // iOS에서는 실제 저장 여부를 확인할 수 없으므로 안내 메시지만 표시
                setTimeout(() => {
                    showIOSDownloadCompleteModal();
                }, 500);
            } catch (error) {
                console.error('다운로드 실패:', error);
                showSaveErrorModal();
            }
            
            document.body.removeChild(link);
        };
        
        // iOS 다운로드 완료 안내 모달
        function showIOSDownloadCompleteModal() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 15px;
                    padding: 30px;
                    max-width: 90%;
                    text-align: center;
                ">
                    <div style="font-size: 48px; margin-bottom: 20px;">📱</div>
                    <h3 style="margin: 0 0 20px 0; color: #333; font-size: 18px;">다운로드 시도 완료</h3>
                    <p style="margin: 0 0 20px 0; color: #666; font-size: 14px; line-height: 1.5;">
                        다운로드를 시도했습니다.<br>
                        <strong>만약 저장이 안 되었다면</strong> 이미지를 길게 눌러서 "이미지 저장"을 선택해주세요.
                    </p>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        padding: 12px 24px;
                        background: #667eea;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 14px;
                        cursor: pointer;
                    ">확인</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 모달 외부 클릭 시 닫기
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        // Android Chrome 갤러리 저장
        function saveToGalleryAndroid(blob, fileName) {
            // Android에서는 File System Access API 시도
            if ('showSaveFilePicker' in window) {
                const file = new File([blob], fileName, { type: 'image/jpeg' });
                window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{
                        description: 'JPEG images',
                        accept: { 'image/jpeg': ['.jpg'] }
                    }]
                }).then(fileHandle => {
                    return fileHandle.createWritable();
                }).then(writable => {
                    return writable.write(file);
                }).then(() => {
                    showSaveSuccessModal();
                }).catch(error => {
                    console.log('File System Access API 실패:', error);
                    saveToGalleryGeneric(blob, fileName);
                });
            } else {
                saveToGalleryGeneric(blob, fileName);
            }
        }
        
        // 일반 모바일 브라우저 갤러리 저장
        function saveToGalleryGeneric(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            link.style.display = 'none';
            document.body.appendChild(link);
            
            try {
                link.click();
                // 일반 브라우저에서는 성공 모달 표시
                setTimeout(() => {
                    showSaveSuccessModal();
                }, 500);
            } catch (error) {
                console.log('일반 다운로드 실패:', error);
                showSaveModal(url, fileName);
            }
            
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        // 저장 성공 모달
        function showSaveSuccessModal() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 15px;
                    padding: 30px;
                    max-width: 90%;
                    text-align: center;
                ">
                    <div style="font-size: 48px; margin-bottom: 20px;">✅</div>
                    <h3 style="margin: 0 0 20px 0; color: #333; font-size: 18px;">갤러리에 저장되었습니다!</h3>
                    <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;">
                        이미지가 갤러리에 성공적으로 저장되었습니다
                    </p>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        padding: 12px 24px;
                        background: #667eea;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 14px;
                        cursor: pointer;
                    ">확인</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 3초 후 자동 닫기
            setTimeout(() => {
                if (modal.parentNode) {
                    modal.remove();
                }
            }, 3000);
        }
        
        // 저장 모달 (대안 방법)
        function showSaveModal(dataURL, fileName) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 15px;
                    padding: 30px;
                    max-width: 90%;
                    max-height: 90%;
                    text-align: center;
                    overflow-y: auto;
                ">
                    <h3 style="margin: 0 0 20px 0; color: #333; font-size: 18px;">이미지가 준비되었습니다</h3>
                    <img src="${dataURL}" style="
                        max-width: 100%;
                        height: auto;
                        border: 2px solid #667eea;
                        border-radius: 10px;
                        margin-bottom: 20px;
                    ">
                    <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;">
                        이미지를 길게 눌러 "이미지 저장" 또는 "사진에 저장"을 선택하세요
                    </p>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                            padding: 12px 24px;
                            background: #667eea;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            font-size: 14px;
                            cursor: pointer;
                        ">닫기</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 모달 외부 클릭 시 닫기
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        // 저장 오류 모달
        function showSaveErrorModal() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 15px;
                    padding: 30px;
                    max-width: 90%;
                    text-align: center;
                ">
                    <div style="font-size: 48px; margin-bottom: 20px;">❌</div>
                    <h3 style="margin: 0 0 20px 0; color: #333; font-size: 18px;">저장 실패</h3>
                    <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;">
                        이미지 저장에 실패했습니다. 다시 시도해주세요.
                    </p>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        padding: 12px 24px;
                        background: #667eea;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 14px;
                        cursor: pointer;
                    ">확인</button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // 최종 이미지 다운로드 (새로운 시스템 사용)
        function downloadFinalImage() {
            compositeSystem.downloadImage();
        }
        
        // 편집 핸들 디버깅 함수 (개발자 콘솔에서 사용) - 비활성화
        window.debugEditHandles = function(enable = false) {
            window.debugEditHandles = enable;
            if (enable) {
                console.log('편집 핸들 디버깅 활성화됨');
                syncEditHandlesWithContent();
            } else {
                console.log('편집 핸들 디버깅 비활성화됨');
                const debugDiv = document.getElementById('debugEditHandles');
                if (debugDiv) {
                    debugDiv.remove();
                }
            }
        };
        
        // 이벤트 리스너
        backgroundInput.addEventListener('change', async (e) => {
            console.log('배경 이미지 업로드 시작');
            const file = e.target.files[0];
            if (file) {
                console.log('파일 선택됨:', file.name);
                try {
                    const compressed = await compressImage(file);
                    backgroundImage = URL.createObjectURL(compressed);
                    
                    // 업로드 영역을 체크 아이콘으로 교체
                    const uploadArea = document.getElementById('backgroundUploadArea');
                    const checkArea = document.getElementById('backgroundCheckArea');
                    uploadArea.style.display = 'none';
                    checkArea.style.display = 'block';
                    
                    // 다음 단계 버튼 표시
                    document.getElementById('nextButtonContainer').style.display = 'block';
                    
                    console.log('배경 이미지 업로드 완료');
                } catch (error) {
                    console.error('배경 이미지 처리 오류:', error);
                }
            }
        });
        
        calligraphyInput.addEventListener('change', async (e) => {
            console.log('글씨 이미지 업로드 시작');
            const file = e.target.files[0];
            if (file) {
                console.log('글씨 파일 선택됨:', file.name);
                
                try {
                    const compressed = await compressImage(file);
                    calligraphyImage = URL.createObjectURL(compressed);
                    
                    // 점선 영역을 사진으로 교체
                    const uploadArea = calligraphyInput.closest('.file-upload-area');
                    if (uploadArea) {
                    uploadArea.style.display = 'none';
                    }
                    
                    console.log('글씨 이미지 업로드 완료, 자동으로 다음 단계로 이동');
                    // 자동으로 다음 단계로 이동
                    setTimeout(async () => {
                        // 글씨 이미지 자동 보정 처리
                        if (calligraphyImage) {
                            try {
                    const processed = await processCalligraphyImage(calligraphyImage);
                    processedCalligraphy = URL.createObjectURL(processed);
                    processedCalligraphyEl.src = processedCalligraphy;
                    
                    // 새로운 크롭 시스템 초기화
                    setTimeout(() => {
                        initCropArea();
                        setupCropEvents();
                    }, 100);
                            } catch (error) {
                                console.error('글씨 이미지 처리 오류:', error);
                            }
                        }
                        nextStep();
                    }, 500); // 0.5초 후 자동 이동
                } catch (error) {
                    console.error('글씨 이미지 처리 오류:', error);
                }
            }
        });
        
        
        // 크롭 핸들 드래그 이벤트
        let isResizing = false;
        let isMoving = false;
        let resizeDirection = '';
        let startMousePos = { x: 0, y: 0 };
        let startCropArea = { x: 0, y: 0, width: 100, height: 100 };
        
        // 크롭 영역 초기화 (새로운 시스템 사용)
        function initCropArea() {
            cropSystem.cropArea = { x: 10, y: 10, width: 80, height: 80 };
            
            // 이미지가 로드된 후 크롭 핸들 업데이트
            setTimeout(() => {
                const cropAreaEl = document.getElementById('cropArea');
                if (cropAreaEl) {
                    cropSystem.updateCropHandles(cropAreaEl);
                }
            }, 100);
        }
        
        // 크롭 핸들 업데이트 (새로운 시스템 사용)
        function updateCropHandles() {
            const cropAreaEl = document.getElementById('cropArea');
            if (cropAreaEl) {
                cropSystem.updateCropHandles(cropAreaEl);
            }
        }
        
        // 새로운 정확한 크롭 이벤트 시스템
        function setupCropEvents() {
            const img = document.getElementById('processedCalligraphy');
            const cropAreaEl = document.getElementById('cropArea');
            
            if (!img || !cropAreaEl) {
                console.log('크롭 이벤트 설정 실패: 이미지 또는 크롭 영역 요소를 찾을 수 없음');
                return;
            }
            
            console.log('크롭 이벤트 설정 완료');
            
            // 크롭 핸들 이벤트는 updateHandles에서 설정됨
            
            // 크롭 영역 드래그 이벤트 (마우스 + 터치)
            cropAreaEl.addEventListener('mousedown', (e) => {
                // 핸들을 클릭한 경우 드래그 시작하지 않음
                if (e.target.classList.contains('crop-handle')) {
                    console.log('핸들 클릭 감지 - 드래그 시작하지 않음');
                    return;
                }
                
                console.log('크롭 영역 드래그 시작');
                cropSystem.isDragging = true;
                cropSystem.startPos = { x: e.clientX, y: e.clientY };
                cropSystem.startCropArea = { ...cropSystem.cropArea };
                e.preventDefault();
                e.stopPropagation();
            });

            cropAreaEl.addEventListener('touchstart', (e) => {
                // 핸들을 클릭한 경우 드래그 시작하지 않음
                if (e.target.classList.contains('crop-handle')) {
                    console.log('핸들 클릭 감지 - 드래그 시작하지 않음');
                    return;
                }
                
                console.log('크롭 영역 터치 드래그 시작');
                cropSystem.isDragging = true;
                const touch = e.touches[0];
                // 터치 좌표를 더 정확하게 저장
                cropSystem.startPos = { 
                    x: touch.clientX, 
                    y: touch.clientY,
                    pageX: touch.pageX,
                    pageY: touch.pageY
                };
                cropSystem.startCropArea = { ...cropSystem.cropArea };
                // 모바일 최적화: 즉시 드래그 허용
                cropSystem.minMoveDistance = 0; // 모바일에서는 즉시 반응
                cropSystem.hasMoved = true; // 이미 움직인 것으로 간주
                e.preventDefault();
                e.stopPropagation();
            });
            
            // 마우스 이동 이벤트
            document.addEventListener('mousemove', (e) => {
                if (cropSystem.isResizing) {
                    const displayBounds = cropSystem.getImageDisplayBounds(img);
                    const deltaX = ((e.clientX - cropSystem.startPos.x) / displayBounds.width) * 100;
                    const deltaY = ((e.clientY - cropSystem.startPos.y) / displayBounds.height) * 100;
                    
                    console.log('크롭 리사이징:', {
                        direction: cropSystem.resizeHandle,
                        deltaX, deltaY,
                        startPos: cropSystem.startPos,
                        currentPos: { x: e.clientX, y: e.clientY }
                    });
                    
                    let newCropArea = { ...cropSystem.startCropArea };
                    
                    // 리사이징 방향에 따른 처리
                    switch(cropSystem.resizeHandle) {
                        case 'nw': // 왼쪽 위
                            newCropArea.x = Math.max(0, cropSystem.startCropArea.x + deltaX);
                            newCropArea.y = Math.max(0, cropSystem.startCropArea.y + deltaY);
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width - deltaX);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height - deltaY);
                            break;
                        case 'ne': // 오른쪽 위
                            newCropArea.y = Math.max(0, cropSystem.startCropArea.y + deltaY);
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width + deltaX);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height - deltaY);
                            break;
                        case 'sw': // 왼쪽 아래
                            newCropArea.x = Math.max(0, cropSystem.startCropArea.x + deltaX);
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width - deltaX);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height + deltaY);
                            break;
                        case 'se': // 오른쪽 아래
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width + deltaX);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height + deltaY);
                            break;
                        case 'n': // 위
                            newCropArea.y = Math.max(0, cropSystem.startCropArea.y + deltaY);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height - deltaY);
                            break;
                        case 's': // 아래
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height + deltaY);
                            break;
                        case 'w': // 왼쪽
                            newCropArea.x = Math.max(0, cropSystem.startCropArea.x + deltaX);
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width - deltaX);
                            break;
                        case 'e': // 오른쪽
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width + deltaX);
                            break;
                    }
                    
                    // 경계 체크
                    if (newCropArea.x + newCropArea.width > 100) {
                        newCropArea.width = 100 - newCropArea.x;
                    }
                    if (newCropArea.y + newCropArea.height > 100) {
                        newCropArea.height = 100 - newCropArea.y;
                    }
                    
                    cropSystem.cropArea = newCropArea;
                    cropSystem.updateCropHandles();
                } else if (cropSystem.isDragging) {
                    const displayBounds = cropSystem.getImageDisplayBounds(img);
                    const deltaX = ((e.clientX - cropSystem.startPos.x) / displayBounds.width) * 100;
                    const deltaY = ((e.clientY - cropSystem.startPos.y) / displayBounds.height) * 100;
                    
                    let newCropArea = { ...cropSystem.startCropArea };
                    newCropArea.x = Math.max(0, Math.min(100 - newCropArea.width, cropSystem.startCropArea.x + deltaX));
                    newCropArea.y = Math.max(0, Math.min(100 - newCropArea.height, cropSystem.startCropArea.y + deltaY));
                    
                    cropSystem.cropArea = newCropArea;
                    cropSystem.updateCropHandles();
                }
            });

            // 터치 이동 이벤트 (최적화 및 감도 개선)
            document.addEventListener('touchmove', (e) => {
                if (cropSystem.isResizing || cropSystem.isDragging) {
                    e.preventDefault(); // 터치 스크롤 방지
                    e.stopPropagation();
                    
                    if (cropSystem.isResizing) {
                        const displayBounds = cropSystem.getImageDisplayBounds(img);
                        const touch = e.touches[0];
                        
                        // 모바일에서는 즉시 움직임 허용 (hasMoved가 이미 true로 설정됨)
                        if (!cropSystem.hasMoved) {
                            cropSystem.hasMoved = true;
                            console.log('리사이징 시작');
                        }
                        
                        // 터치 감도 개선: 자연스러운 반응
                        const sensitivity = 1.5; // 감도 조정 (자연스러운 움직임)
                        const deltaX = ((touch.clientX - cropSystem.startPos.x) / displayBounds.width) * 100 * sensitivity;
                        const deltaY = ((touch.clientY - cropSystem.startPos.y) / displayBounds.height) * 100 * sensitivity;
                        
                        let newCropArea = { ...cropSystem.startCropArea };
                        
                        // 리사이징 방향에 따른 처리
                        switch(cropSystem.resizeHandle) {
                            case 'nw': // 왼쪽 위
                                newCropArea.x = Math.max(0, cropSystem.startCropArea.x + deltaX);
                                newCropArea.y = Math.max(0, cropSystem.startCropArea.y + deltaY);
                                newCropArea.width = Math.max(5, cropSystem.startCropArea.width - deltaX);
                                newCropArea.height = Math.max(5, cropSystem.startCropArea.height - deltaY);
                                break;
                            case 'ne': // 오른쪽 위
                                newCropArea.y = Math.max(0, cropSystem.startCropArea.y + deltaY);
                                newCropArea.width = Math.max(5, cropSystem.startCropArea.width + deltaX);
                                newCropArea.height = Math.max(5, cropSystem.startCropArea.height - deltaY);
                                break;
                            case 'sw': // 왼쪽 아래
                                newCropArea.x = Math.max(0, cropSystem.startCropArea.x + deltaX);
                                newCropArea.width = Math.max(5, cropSystem.startCropArea.width - deltaX);
                                newCropArea.height = Math.max(5, cropSystem.startCropArea.height + deltaY);
                                break;
                            case 'se': // 오른쪽 아래
                                newCropArea.width = Math.max(5, cropSystem.startCropArea.width + deltaX);
                                newCropArea.height = Math.max(5, cropSystem.startCropArea.height + deltaY);
                                break;
                            case 'n': // 위
                                newCropArea.y = Math.max(0, cropSystem.startCropArea.y + deltaY);
                                newCropArea.height = Math.max(5, cropSystem.startCropArea.height - deltaY);
                                break;
                            case 's': // 아래
                                newCropArea.height = Math.max(5, cropSystem.startCropArea.height + deltaY);
                                break;
                            case 'w': // 왼쪽
                                newCropArea.x = Math.max(0, cropSystem.startCropArea.x + deltaX);
                                newCropArea.width = Math.max(5, cropSystem.startCropArea.width - deltaX);
                                break;
                            case 'e': // 오른쪽
                                newCropArea.width = Math.max(5, cropSystem.startCropArea.width + deltaX);
                                break;
                        }
                        
                        // 경계 체크
                        if (newCropArea.x + newCropArea.width > 100) {
                            newCropArea.width = 100 - newCropArea.x;
                        }
                        if (newCropArea.y + newCropArea.height > 100) {
                            newCropArea.height = 100 - newCropArea.y;
                        }
                        
                        cropSystem.cropArea = newCropArea;
                        
                        // 디바운싱을 위한 setTimeout 사용 (즉시 업데이트)
                        if (touchUpdateTimeout) {
                            clearTimeout(touchUpdateTimeout);
                        }
                        touchUpdateTimeout = setTimeout(() => {
                            cropSystem.updateCropHandles();
                        }, 50); // 50ms 디바운싱으로 안정성 향상
                    } else if (cropSystem.isDragging) {
                        const displayBounds = cropSystem.getImageDisplayBounds(img);
                        const touch = e.touches[0];
                        
                        // 모바일에서는 즉시 움직임 허용 (hasMoved가 이미 true로 설정됨)
                        if (!cropSystem.hasMoved) {
                            cropSystem.hasMoved = true;
                            console.log('드래그 시작');
                        }
                        
                        // 드래깅 감도도 개선 (자연스러운 반응)
                        const sensitivity = 1.5; // 감도 조정 (자연스러운 움직임)
                        const deltaX = ((touch.clientX - cropSystem.startPos.x) / displayBounds.width) * 100 * sensitivity;
                        const deltaY = ((touch.clientY - cropSystem.startPos.y) / displayBounds.height) * 100 * sensitivity;
                        
                        let newCropArea = { ...cropSystem.startCropArea };
                        newCropArea.x = Math.max(0, Math.min(100 - newCropArea.width, cropSystem.startCropArea.x + deltaX));
                        newCropArea.y = Math.max(0, Math.min(100 - newCropArea.height, cropSystem.startCropArea.y + deltaY));
                        
                        cropSystem.cropArea = newCropArea;
                        
                        // 디바운싱을 위한 setTimeout 사용 (즉시 업데이트)
                        if (touchUpdateTimeout) {
                            clearTimeout(touchUpdateTimeout);
                        }
                        touchUpdateTimeout = setTimeout(() => {
                            cropSystem.updateCropHandles();
                        }, 50); // 50ms 디바운싱으로 안정성 향상
                    }
                }
            }, { passive: false }); // passive: false로 설정하여 preventDefault 가능
            
            // 마우스 업 이벤트
            document.addEventListener('mouseup', () => {
                // 리사이징 또는 드래깅 상태였는지 확인
                const wasResizing = cropSystem.isResizing;
                const wasDragging = cropSystem.isDragging;
                
                cropSystem.isResizing = false;
                cropSystem.isDragging = false;
                cropSystem.hasMoved = false; // 상태 완전 리셋
                cropSystem.minMoveDistance = 0; // 최소 이동 거리 리셋
                
                // 마우스 종료 시점에서 크롭 핸들 즉시 업데이트
                if (wasResizing || wasDragging) {
                    setTimeout(() => {
                        cropSystem.updateCropHandles();
                        console.log('마우스 종료 후 크롭 핸들 업데이트 완료');
                    }, 10);
                }
            });

            // 터치 종료 이벤트
            document.addEventListener('touchend', (e) => {
                // 리사이징 또는 드래깅 상태였는지 확인
                const wasResizing = cropSystem.isResizing;
                const wasDragging = cropSystem.isDragging;
                
                // 상태 완전 리셋
                cropSystem.isResizing = false;
                cropSystem.isDragging = false;
                cropSystem.hasMoved = false;
                cropSystem.minMoveDistance = 0;
                cropSystem.startPos = null;
                cropSystem.startCropArea = null;
                
                // 디바운싱 타이머 정리
                if (touchUpdateTimeout) {
                    clearTimeout(touchUpdateTimeout);
                    touchUpdateTimeout = null;
                }
                
                // 터치 종료 시점에서 크롭 핸들 즉시 업데이트
                if (wasResizing || wasDragging) {
                    // 즉시 업데이트 (지연 없음)
                    cropSystem.updateCropHandles();
                    console.log('터치 종료 후 크롭 핸들 업데이트 완료');
                }
                
                // 터치 이벤트 전파 방지
                e.preventDefault();
                e.stopPropagation();
            }, { passive: false });
        }
        
        // 편집 핸들 변수
        let isEditing = false;
        let editType = '';
        let editStart = { x: 0, y: 0, scale: 1, rotation: 0 };
        
        // 새로운 합성 미리보기 드래그 이벤트 (마우스 + 터치)
        calligraphyOverlay.addEventListener('mousedown', (e) => {
            // 편집 핸들이 아닌 경우에만 위치 이동
            if (!e.target.classList.contains('edit-handle')) {
                isDragging = true;
                const rect = compositePreview.getBoundingClientRect();
                dragStart = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                e.preventDefault();
            }
        });

        // 터치 이벤트 추가 (최적화)
        calligraphyOverlay.addEventListener('touchstart', (e) => {
            // 편집 핸들이 아닌 경우에만 위치 이동
            if (!e.target.classList.contains('edit-handle')) {
                isDragging = true;
                const rect = compositePreview.getBoundingClientRect();
                const touch = e.touches[0];
                dragStart = {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
                e.preventDefault();
                e.stopPropagation();
            }
        }, { passive: false });
        
        // 크기 조정 핸들 (마우스 + 터치)
        document.getElementById('scaleHandle').addEventListener('mousedown', (e) => {
            isEditing = true;
            editType = 'scale';
            editStart = {
                x: e.clientX,
                y: e.clientY,
                scale: compositeSystem.scale,
                rotation: compositeSystem.rotation
            };
            e.preventDefault();
            e.stopPropagation();
        });

        document.getElementById('scaleHandle').addEventListener('touchstart', (e) => {
            isEditing = true;
            editType = 'scale';
            const touch = e.touches[0];
            editStart = {
                x: touch.clientX,
                y: touch.clientY,
                scale: compositeSystem.scale,
                rotation: compositeSystem.rotation
            };
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });
        
        // 회전 핸들 (마우스 + 터치)
        document.getElementById('rotateHandle').addEventListener('mousedown', (e) => {
            isEditing = true;
            editType = 'rotate';
            editStart = {
                x: e.clientX,
                y: e.clientY,
                scale: compositeSystem.scale,
                rotation: compositeSystem.rotation
            };
            e.preventDefault();
            e.stopPropagation();
        });

        document.getElementById('rotateHandle').addEventListener('touchstart', (e) => {
            isEditing = true;
            editType = 'rotate';
            const touch = e.touches[0];
            editStart = {
                x: touch.clientX,
                y: touch.clientY,
                scale: compositeSystem.scale,
                rotation: compositeSystem.rotation
            };
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });
        
        // 마우스 이동 이벤트
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = compositePreview.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                    const newX = Math.max(0, Math.min(100, ((x / rect.width) * 100)));
                    const newY = Math.max(0, Math.min(100, ((y / rect.height) * 100)));
                    
                    compositeSystem.updatePosition(newX, newY);
                    // 드래그 중에는 편집 핸들 동기화 하지 않음 (깜빡거림 방지)
            } else if (isEditing) {
                const deltaX = e.clientX - editStart.x;
                const deltaY = e.clientY - editStart.y;
                
                if (editType === 'scale') {
                    // 크기 조정 (대각선 방향만, 감도 조절)
                    const diagonalDistance = (deltaX + deltaY) / Math.sqrt(2); // 대각선 거리
                    const scaleFactor = 1 + (diagonalDistance / 800); // 감도 조절
                    const newScale = Math.max(0.1, Math.min(2, editStart.scale * scaleFactor));
                    compositeSystem.updateScale(newScale);
                    // 편집 중에는 편집 핸들 동기화 하지 않음 (깜빡거림 방지)
                } else if (editType === 'rotate') {
                    // 회전 조정 (중심점 기준, 감도 조절)
                    const centerX = editStart.x;
                    const centerY = editStart.y;
                    const startAngle = Math.atan2(editStart.y - centerY, editStart.x - centerX);
                    const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    const angleDiff = (currentAngle - startAngle) * (180 / Math.PI);
                    const rotationSensitivity = 0.3; // 회전 감도 50%로 조절
                    const newRotation = editStart.rotation + (angleDiff * rotationSensitivity);
                    compositeSystem.updateRotation(newRotation);
                    // 편집 중에는 편집 핸들 동기화 하지 않음 (깜빡거림 방지)
                }
            }
        });

        // 터치 이동 이벤트 (최적화)
        document.addEventListener('touchmove', (e) => {
            // 터치 이벤트가 드래그나 편집 중일 때만 처리
            if (isDragging || isEditing) {
                e.preventDefault(); // 터치 스크롤 방지
                e.stopPropagation();
                
                if (isDragging) {
                    const rect = compositePreview.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // 모바일 터치 감도 개선
                    const sensitivity = 1.2; // 터치 감도 배수
                    const newX = Math.max(0, Math.min(100, ((x / rect.width) * 100 * sensitivity)));
                    const newY = Math.max(0, Math.min(100, ((y / rect.height) * 100 * sensitivity)));
                    
                    // requestAnimationFrame으로 성능 최적화
                    requestAnimationFrame(() => {
                        compositeSystem.updatePosition(newX, newY);
                    });
                } else if (isEditing) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - editStart.x;
                    const deltaY = touch.clientY - editStart.y;
                    
                    if (editType === 'scale') {
                        // 크기 조정 (대각선 방향만, 감도 조절)
                        const diagonalDistance = (deltaX + deltaY) / Math.sqrt(2); // 대각선 거리
                        const scaleFactor = 1 + (diagonalDistance / 800); // 감도 조절
                        const newScale = Math.max(0.1, Math.min(2, editStart.scale * scaleFactor));
                        
                        requestAnimationFrame(() => {
                            compositeSystem.updateScale(newScale);
                        });
                    } else if (editType === 'rotate') {
                        // 회전 조정 (중심점 기준, 감도 조절)
                        const centerX = editStart.x;
                        const centerY = editStart.y;
                        const startAngle = Math.atan2(editStart.y - centerY, editStart.x - centerX);
                        const currentAngle = Math.atan2(touch.clientY - centerY, touch.clientX - centerX);
                        const angleDiff = (currentAngle - startAngle) * (180 / Math.PI);
                        const rotationSensitivity = 0.3; // 회전 감도 50%로 조절
                        const newRotation = editStart.rotation + (angleDiff * rotationSensitivity);
                        
                        requestAnimationFrame(() => {
                            compositeSystem.updateRotation(newRotation);
                        });
                    }
                }
            }
        }, { passive: false }); // passive: false로 설정하여 preventDefault 가능
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            isEditing = false;
            // 드래그/편집이 끝났을 때 편집 핸들 동기화
            if (croppedCalligraphy) {
                setTimeout(() => {
                    syncEditHandlesWithContent();
                }, 100);
            }
        });

        document.addEventListener('touchend', () => {
            isDragging = false;
            isEditing = false;
            // 드래그/편집이 끝났을 때 편집 핸들 동기화
            if (croppedCalligraphy) {
                setTimeout(() => {
                    syncEditHandlesWithContent();
                }, 100);
            }
        });
        
        // 블렌드 모드 버튼 이벤트
        multiplyMode.addEventListener('click', () => {
            compositeSystem.updateBlendMode('multiply');
            multiplyMode.classList.add('active');
            screenMode.classList.remove('active');
        });
        
        screenMode.addEventListener('click', () => {
            compositeSystem.updateBlendMode('screen');
            screenMode.classList.add('active');
            multiplyMode.classList.remove('active');
        });
        
        // 모바일 뷰포트 높이 동적 계산 및 적용
        function updateMobileViewportHeight() {
            if (window.innerWidth <= 768) {
                const vh = window.innerHeight * 0.01;
                const dvh = window.innerHeight * 0.01;
                
                // CSS 변수로 동적 뷰포트 높이 설정
                document.documentElement.style.setProperty('--vh', `${vh}px`);
                document.documentElement.style.setProperty('--dvh', `${dvh}px`);
                
                // 안전 영역 고려한 높이 계산
                const safeAreaTop = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-inset-top') || '0');
                const safeAreaBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-inset-bottom') || '0');
                
                const adjustedHeight = window.innerHeight - safeAreaTop - safeAreaBottom;
                document.documentElement.style.setProperty('--adjusted-vh', `${adjustedHeight}px`);
                
                console.log('모바일 뷰포트 높이 업데이트:', {
                    innerHeight: window.innerHeight,
                    vh: vh,
                    safeAreaTop,
                    safeAreaBottom,
                    adjustedHeight
                });
            }
        }
        
        // 초기 로드 시 및 리사이즈 시 뷰포트 높이 업데이트
        updateMobileViewportHeight();
        window.addEventListener('resize', updateMobileViewportHeight);
        window.addEventListener('orientationchange', () => {
            setTimeout(updateMobileViewportHeight, 100);
        });
        
        // 버튼 이벤트
        document.getElementById('nextToStep2').addEventListener('click', nextStep);
        document.getElementById('nextToStep4').addEventListener('click', async () => {
            // 크롭된 이미지 생성
            if (processedCalligraphy) {
                croppedCalligraphy = await cropSystem.cropImage(processedCalligraphy, cropSystem.cropArea);
                croppedCalligraphy = URL.createObjectURL(croppedCalligraphy);
                
                console.log('크롭된 이미지 생성 완료:', croppedCalligraphy);
                
                // 크롭 완료 후 합성 시스템의 경계 다시 감지 및 미리보기 업데이트
                setTimeout(() => {
                    compositeSystem.detectImageBounds().then(() => {
                        updateCompositePreview();
                        // 편집 핸들 업데이트를 별도로 호출
                        setTimeout(() => {
                            updateEditHandles();
                        }, 200);
                    });
                }, 100);
            }
            nextStep();
        });
        document.getElementById('downloadBtn').addEventListener('click', downloadFinalImage);
        document.getElementById('restartBtn').addEventListener('click', () => {
            location.reload();
        });
        
        // 파일 드래그 앤 드롭
        document.querySelectorAll('.file-upload-area').forEach(area => {
            area.addEventListener('dragover', (e) => {
                e.preventDefault();
                area.classList.add('dragover');
            });
            
            area.addEventListener('dragleave', () => {
                area.classList.remove('dragover');
            });
            
            area.addEventListener('drop', async (e) => {
                e.preventDefault();
                area.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        // 배경사진 업로드 영역인지 확인
                        const isBackgroundArea = area.querySelector('#backgroundInput') || 
                                               area.previousElementSibling?.id === 'backgroundInput';
                        
                        if (isBackgroundArea) {
                            backgroundInput.files = files;
                            backgroundInput.dispatchEvent(new Event('change'));
                        } else {
                            calligraphyInput.files = files;
                            calligraphyInput.dispatchEvent(new Event('change'));
                        }
                    }
                }
            });
        });
        
        // 햄버거 메뉴 동작
        const menuBtn = document.getElementById('menu-hamburger');
        const menuPopup = document.getElementById('menu-popup');
        menuBtn.onclick = (e) => {
          e.stopPropagation();
          menuPopup.style.display = (menuPopup.style.display === 'none' || menuPopup.style.display === '') ? 'block' : 'none';
        };
        // 메뉴 바깥 클릭 시 닫기
        window.addEventListener('click', (e) => {
          if (menuPopup.style.display === 'block' && !menuPopup.contains(e.target) && e.target !== menuBtn) {
            menuPopup.style.display = 'none';
          }
        });
        
        // 창 크기 변경 시 배경 이미지 재조정 및 편집 핸들 업데이트
        window.addEventListener('resize', () => {
            const compositeBackground = document.getElementById('compositeBackground');
            if (compositeBackground && compositeBackground.src) {
                setTimeout(() => {
                    adjustBackgroundImageSize(compositeBackground);
                    // 편집 핸들도 함께 업데이트
                    updateEditHandles();
                    // 크롭된 이미지가 있으면 내용 영역에 맞춰 재정렬
                    if (croppedCalligraphy) {
                        setTimeout(() => {
                            syncEditHandlesWithContent();
                        }, 50);
                    }
                }, 100);
            }
        });
        
        // 초기화
        showStep(1);
        
        // 기존 디버그 영역 제거
        const existingDebug = document.getElementById('debugEditHandles');
        if (existingDebug) {
            existingDebug.remove();
        }
        
        // 페이지 로드 시 단계 표시 초기화
        window.addEventListener('load', () => {
            showStep(1);
            // 페이지 로드 시에도 디버그 영역 제거
            const debugDiv = document.getElementById('debugEditHandles');
            if (debugDiv) {
                debugDiv.remove();
            }
        });
    </script>
</body>
</html>
