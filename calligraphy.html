<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìº˜ë¦¬ê·¸ë¼í”¼ í•©ì„±ê¸°</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Jua', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Jua', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            max-height: 100vh;
            overflow-y: auto;
            margin: 0;
            padding: 0;
        }
        
        /* ëª¨ë“  ìš”ì†Œì— Jua í°íŠ¸ ê°•ì œ ì ìš© */
        *, *::before, *::after {
            font-family: 'Jua', sans-serif !important;
        }
        
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .custom-modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 90vw;
            max-height: 90vh;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        .custom-modal h3 {
            font-size: 1.5rem;
            /* font-weight: bold; */
            margin-bottom: 20px;
            color: #333;
        }
        
        .custom-modal p {
            margin-bottom: 20px;
            color: #666;
        }
        
        .custom-modal button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: transform 0.2s;
        }
        
        .custom-modal button:hover {
            transform: translateY(-2px);
        }
        
        .custom-modal button.secondary {
            background: #e5e7eb;
            color: #374151;
        }
        
        .step {
            display: none;
            max-height: 100vh;
            overflow-y: auto;
        }
        
        .step.active {
            display: block;
            max-height: 100vh;
            overflow-y: auto;
        }
        
        .image-preview {
            max-width: 100%;
            max-height: 60vh;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin: 20px auto;
            display: block;
            object-fit: contain;
            object-position: center;
        }
        
        .crop-overlay {
            position: relative;
            display: inline-block;
            border-radius: 10px;
            overflow: hidden;
            max-width: 90vw;
            max-height: 70vh;
        }
        
        .crop-area {
            position: absolute;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            cursor: move;
            z-index: 5;
            pointer-events: auto;
        }
        
        .crop-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
        }
        
        .crop-handle.nw { top: -10px; left: -10px; cursor: nw-resize; }
        .crop-handle.ne { top: -10px; right: -10px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -10px; left: -10px; cursor: sw-resize; }
        .crop-handle.se { bottom: -10px; right: -10px; cursor: se-resize; }
        
        .crop-handle.n { top: -10px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .crop-handle.s { bottom: -10px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .crop-handle.w { left: -10px; top: 50%; transform: translateY(-50%); cursor: w-resize; }
        .crop-handle.e { right: -10px; top: 50%; transform: translateY(-50%); cursor: e-resize; }
        
        .composite-preview-container {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            width: 100% !important;
            height: calc(100vh - 400px); /* ìœ„/ì•„ë˜ ë²„íŠ¼ ê³µê°„ ì œì™¸í•˜ê³  ìµœëŒ€ ë†’ì´ */
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            position: static;
            margin-bottom: 20px;
            overflow: visible;
        }
        
        .composite-preview {
            position: relative;
            display: block;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            background: transparent;
            margin: 0 auto !important;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            text-align: center;
            aspect-ratio: auto;
        }
        
        /* 770px ì´ìƒì—ì„œ ì»¨í…Œì´ë„ˆ í¬ê¸° ê³ ì • */
        @media (min-width: 770px) {
            .composite-preview-container {
                height: calc(100vh - 200px); /* ìœ„/ì•„ë˜ ë²„íŠ¼ ê³µê°„ ì œì™¸í•˜ê³  ìµœëŒ€ ë†’ì´ */
                padding: 20px;
                width: 100% !important;
            }
            
            .composite-preview {
                max-width: 100%;
                max-height: 100%;
                width: 100%;
                height: 100%;
            }
        }
        
        /* 1200px ì´ìƒì—ì„œ ë” í° ì»¨í…Œì´ë„ˆ */
        @media (min-width: 1200px) {
            .composite-preview-container {
                height: calc(100vh - 180px); /* ìœ„/ì•„ë˜ ë²„íŠ¼ ê³µê°„ ì œì™¸í•˜ê³  ìµœëŒ€ ë†’ì´ */
                padding: 30px;
            }
            
            .composite-preview {
                max-width: 100%;
                max-height: 100%;
                width: 100%;
                height: 100%;
            }
        }
        
        /* 480px ì´í•˜ì—ì„œ ëª¨ë°”ì¼ ìµœì í™” */
        @media (max-width: 480px) {
            .composite-preview-container {
                height: calc(100vh - 220px); /* ìœ„/ì•„ë˜ ë²„íŠ¼ ê³µê°„ ì œì™¸í•˜ê³  ìµœëŒ€ ë†’ì´ */
                padding: 5px;
            }
            
            .composite-preview {
                max-width: 100%;
                max-height: 100%;
                width: 100%;
                height: 100%;
            }
        }
        
        .composite-preview .background-image {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            object-position: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* ë°°ê²½ ì´ë¯¸ì§€ê°€ ì»¨í…Œì´ë„ˆì— ë§ê²Œ ì „ì²´ê°€ ë³´ì´ë„ë¡ ì¡°ì • */
        .composite-preview {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            position: relative;
            overflow: hidden;
        }
        
        .composite-preview .calligraphy-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            cursor: move;
            background: transparent;
        }
        
        .composite-preview .calligraphy-overlay img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .edit-handles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            box-sizing: border-box;
            z-index: 10;
            overflow: visible;
            display: block;
        }
        
        .edit-handles::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid #667eea;
            /* background: rgba(102, 126, 234, 0.1); */
            pointer-events: none;
            box-sizing: border-box;
        }
        
        /* í¸ì§‘ í•¸ë“¤ì´ calligraphy-overlayì™€ ë™ì¼í•œ transformì„ ê°€ì§€ë„ë¡ */
        .edit-handles {
            transform-origin: center;
        }
        
        .crop-outline {
            position: absolute;
            border: 2px solid #667eea;
            /* background: rgba(102, 126, 234, 0.1); */
            pointer-events: none;
            box-sizing: border-box;
            z-index: 5;
        }
        
        .edit-handle {
            position: absolute;
            width: 40px !important;
            height: 40px !important;
            background: #667eea;
            border: 3px solid #ffffff;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            box-shadow: 0 4px 8px rgba(0,0,0,0.6);
            transition: all 0.2s ease;
            mix-blend-mode: normal !important;
            filter: none !important;
            transform: none !important;
            min-width: 40px !important;
            min-height: 40px !important;
            max-width: 40px !important;
            max-height: 40px !important;
        }
        
        .edit-handle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.8);
            background: #333333;
        }
        
        .edit-handle.scale {
            bottom: -20px;
            right: -20px;
            cursor: se-resize;
        }
        
        .edit-handle.rotate {
            top: -20px;
            right: -20px;
            cursor: grab;
        }
        
        .edit-handle.rotate:active {
            cursor: grabbing;
        }
        
        /* ì•„ì´ì½˜ì´ ë¶€ëª¨ì˜ ìŠ¤ì¼€ì¼ ë³€í™˜ì— ì˜í–¥ë°›ì§€ ì•Šë„ë¡ */
        .calligraphy-overlay {
            transform-origin: center;
        }
        
        .edit-handles {
            transform-origin: center;
        }
        
        .edit-handle {
            transform-origin: center !important;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #374151;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .control-group input[type="color"] {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .blend-mode-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .blend-mode-buttons button {
            padding: 12px 32px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            font-weight: bold;
            margin: 0 10px;
        }
        
        .blend-mode-buttons button.active {
            transform: translateY(-2px);
        }
        
        .blend-mode-buttons button#multiplyMode.active {
            background: white;
            color: black;
        }
        
        .blend-mode-buttons button#screenMode {
            background: black;
            color: white;
        }
        
        .blend-mode-buttons button#screenMode.active {
            background: black;
            color: white;
        }
        
        .file-upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            background: #f8fafc;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .file-upload-area:hover {
            border-color: #667eea;
            background: #f1f5f9;
        }
        
        .file-upload-area.dragover {
            border-color: #667eea;
            background: #e0e7ff;
        }
        
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }
        
        .back-button:hover {
            background: white;
            transform: scale(1.1);
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .step-indicator {
            display: flex;
            justify-content: center;
            margin-top: 30px;
            margin-bottom: 0;
        }
        
        .step-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            margin: 0 8px;
            transition: all 0.3s;
        }
        
        .step-dot.active {
            background: #ffffff;
            transform: scale(1.2);
        }
        
        .step-dot.completed {
            background: rgba(255, 255, 255, 0.5);
        }
        
        #menu-hamburger:hover {
          background: rgba(255,255,255,0.18) !important;
        }
    </style>
</head>
<body>
    <!-- í–„ë²„ê±° ë©”ë‰´ ë²„íŠ¼ ë° ë©”ë‰´ -->
    <div id="menu-hamburger" style="position:fixed;top:24px;right:28px;z-index:9999;cursor:pointer;width:44px;height:44px;display:flex;align-items:center;justify-content:center;background:transparent;border-radius:50%;transition:background 0.18s;">
      <div style="width:26px;height:20px;display:flex;flex-direction:column;justify-content:space-between;">
        <span class="menu-bar" style="display:block;height:4px;width:100%;background:#fff;border-radius:2px;"></span>
        <span class="menu-bar" style="display:block;height:4px;width:100%;background:#fff;border-radius:2px;"></span>
        <span class="menu-bar" style="display:block;height:4px;width:100%;background:#fff;border-radius:2px;"></span>
      </div>
    </div>
    <div id="menu-popup" style="display:none;position:fixed;top:70px;right:32px;z-index:10000;background:#fff;border-radius:16px;box-shadow:0 4px 24px #0003;padding:18px 28px 14px 28px;min-width:180px;text-align:left;">
      <div style="font-size:1.08rem;font-weight:bold;color:#667eea;margin-bottom:10px;">ë©”ë‰´</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='index.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">ë½€ëª¨ë„ë¡œ íƒ€ì´ë¨¸</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='infiniteStairs.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">ë¬´í•œì˜ ê³„ë‹¨</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='website.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">ì›¹ì‚¬ì´íŠ¸</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='habitTracker/index.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">ìŠµê´€ ì¶”ì ê¸°</div>
      <div style="margin-bottom:8px;cursor:pointer;color:#444;padding:7px 0;border-radius:8px;transition:background 0.15s;" onclick="location.href='survey/index.html'" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='none'">ì„¤ë¬¸ì¡°ì‚¬</div>
    </div>
    
    <!-- ë’¤ë¡œê°€ê¸° ë²„íŠ¼ -->
    <button class="back-button" onclick="goBack()" style="display: none;">â†</button>
    
    <!-- ë‹¨ê³„ 1: ë°°ê²½ ì´ë¯¸ì§€ ì—…ë¡œë“œ -->
    <div class="step active" id="step1">
        <div class="container mx-auto px-4 py-4">
            <h1 class="text-3xl text-center text-white mb-8">ìº˜ë¦¬ê·¸ë¼í”¼ í•©ì„±ê¸°</h1>
            
            <div class="max-w-2xl mx-auto">
                    <div class="control-panel">
                        <h2 class="text-xl mb-4 text-center">1. ë°°ê²½ ì‚¬ì§„ ì—…ë¡œë“œ</h2>
                        <div class="file-upload-area" onclick="document.getElementById('backgroundInput').click()">
                            <div class="text-6xl mb-4">ğŸ–¼ï¸</div>
                            <p class="text-lg  mb-2">ë°°ê²½ ì‚¬ì§„ì„ ì„ íƒí•˜ì„¸ìš”</p>
                            <p class="text-gray-600">í´ë¦­í•˜ê±°ë‚˜ ë“œë˜ê·¸í•˜ì—¬ ì—…ë¡œë“œ</p>
                            <input type="file" id="backgroundInput" accept="image/*" style="display: none;">
                        </div>
                        <div id="backgroundPreview" class="mt-4" style="display: none;">
                            <img id="backgroundImage" class="image-preview" alt="ë°°ê²½ ë¯¸ë¦¬ë³´ê¸°">
                        
                        </div>
                    </div>
                    
                <div class="text-center mt-8" id="nextButtonContainer" style="display: none;">
                    <button id="nextToStep2" class="bg-white text-purple-600 px-8 py-3 rounded-full  text-lg shadow-lg hover:shadow-xl transition-all">
                        ë‹¤ìŒ
                    </button>
                </div>
            </div>
            
            <!-- ë‹¨ê³„ í‘œì‹œê¸° -->
            <div class="step-indicator">
                <div class="step-dot active" data-step="1"></div>
                <div class="step-dot" data-step="2"></div>
                <div class="step-dot" data-step="3"></div>
                <div class="step-dot" data-step="4"></div>
            </div>
        </div>
    </div>
    
    <!-- ë‹¨ê³„ 2: ê¸€ì”¨ ì´ë¯¸ì§€ ì—…ë¡œë“œ -->
    <div class="step" id="step2">
        <div class="container mx-auto px-4 py-4">
            <h1 class="text-3xl text-center text-white mb-8">ê¸€ì”¨ ì‚¬ì§„ ì—…ë¡œë“œ</h1>
            
            <div class="max-w-2xl mx-auto">
                    <div class="control-panel">
                    <h2 class="text-xl mb-4 text-center">2. ê¸€ì”¨ ì‚¬ì§„ ì—…ë¡œë“œ</h2>
                        <div class="file-upload-area" onclick="document.getElementById('calligraphyInput').click()">
                            <div class="text-6xl mb-4">âœï¸</div>
                            <p class="text-lg  mb-2">ê¸€ì”¨ ì‚¬ì§„ì„ ì„ íƒí•˜ì„¸ìš”</p>
                            <p class="text-gray-600">í´ë¦­í•˜ê±°ë‚˜ ë“œë˜ê·¸í•˜ì—¬ ì—…ë¡œë“œ</p>
                            <input type="file" id="calligraphyInput" accept="image/*" style="display: none;">
                        </div>
                  
                </div>
                
            </div>
            
            <!-- ë‹¨ê³„ í‘œì‹œê¸° -->
            <div class="step-indicator">
                <div class="step-dot" data-step="1"></div>
                <div class="step-dot active" data-step="2"></div>
                <div class="step-dot" data-step="3"></div>
                <div class="step-dot" data-step="4"></div>
            </div>
        </div>
    </div>
    
    <!-- ë‹¨ê³„ 3: ê¸€ì”¨ ì‚¬ì§„ ë³´ì • ë° ìë¥´ê¸° -->
    <div class="step" id="step3">
        <div class="container mx-auto px-4 py-4">
            <h1 class="text-3xl  text-center text-white mb-8">ê¸€ì”¨ ë¶€ë¶„ ìë¥´ê¸°</h1>
            
            <div class="max-w-7xl mx-auto">
                <div class="control-panel">
                    
                    <div class="text-center">
                        <div class="crop-overlay" id="cropContainer">
                            <img id="processedCalligraphy" class="image-preview" alt="ë³´ì •ëœ ê¸€ì”¨">
                            <div class="crop-area" id="cropArea"></div>
                        </div>
                        
                    </div>
                    
                    <div class="text-center mt-6">
                        <button id="nextToStep4" class="bg-purple-500 text-white px-8 py-3 rounded-full  text-lg shadow-lg hover:shadow-xl transition-all">
                            ìë¥´ê¸° ì™„ë£Œ
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- ë‹¨ê³„ í‘œì‹œê¸° -->
            <div class="step-indicator">
                <div class="step-dot" data-step="1"></div>
                <div class="step-dot" data-step="2"></div>
                <div class="step-dot active" data-step="3"></div>
                <div class="step-dot" data-step="4"></div>
            </div>
        </div>
    </div>
    
    <!-- ë‹¨ê³„ 4: ì‚¬ì§„ í•©ì„± ë° í¸ì§‘ -->
    <div class="step" id="step4">
        <div class="container mx-auto px-4 py-4">
                        
            <div class="max-w-6xl mx-auto">
                <div class="grid md:grid-cols-2 gap-8">
                    <!-- ë¯¸ë¦¬ë³´ê¸° ì˜ì—­ -->
                    <div class="control-panel">
                        <div class="control-group mt-4">
                            <div class="blend-mode-buttons justify-center">
                                <button id="multiplyMode" class="active bg-white text-black px-8 py-3 rounded-full text-base shadow-lg hover:shadow-xl transition-all">ê²€ì€ ê¸€ì”¨</button>
                                <button id="screenMode" class="bg-black text-white px-8 py-3 rounded-full text-base shadow-lg hover:shadow-xl transition-all">í° ê¸€ì”¨</button>
                            </div>
                        </div>
                        <div class="composite-preview-container">
                            <div class="composite-preview" id="compositePreview">
                                <img id="compositeBackground" class="background-image" alt="í•©ì„± ë¯¸ë¦¬ë³´ê¸°">
                                <div class="calligraphy-overlay" id="calligraphyOverlay">
                                    <img id="compositeCalligraphy" alt="ê¸€ì”¨ ì˜¤ë²„ë ˆì´">
                                </div>
                                <div class="edit-handles" id="editHandles">
                                    <div class="edit-handle scale" id="scaleHandle">â†˜</div>
                                    <div class="edit-handle rotate" id="rotateHandle">â†»</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ìƒ‰ìƒ ë° ë¸”ë Œë“œ ëª¨ë“œ -->
                        
                        
                        <div class="text-center mt-6 space-x-4">
                            <button id="restartBtn" class="bg-gray-500 text-white px-8 py-3 rounded-full  text-base shadow-lg hover:shadow-xl transition-all">
                                ë‹¤ì‹œ ì‹œì‘
                            </button>
                            <button id="downloadBtn" class="bg-purple-500 text-white px-8 py-3 rounded-full  text-base shadow-lg hover:shadow-xl transition-all">
                                ë‹¤ìš´ë¡œë“œ
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ë‹¨ê³„ í‘œì‹œê¸° -->
            <div class="step-indicator">
                <div class="step-dot" data-step="1"></div>
                <div class="step-dot" data-step="2"></div>
                <div class="step-dot" data-step="3"></div>
                <div class="step-dot active" data-step="4"></div>
            </div>
        </div>
    </div>
    
    
    <!-- ì»¤ìŠ¤í…€ ëª¨ë‹¬ -->
    <div class="custom-modal" id="customModal">
        <div class="custom-modal-content">
            <h3 id="modalTitle">ì•Œë¦¼</h3>
            <p id="modalMessage">ë©”ì‹œì§€ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
            <div>
                <button id="modalConfirm" onclick="closeModal()">í™•ì¸</button>
                <button id="modalCancel" onclick="closeModal()" class="secondary" style="display: none;">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let backgroundImage = null;
        let calligraphyImage = null;
        let processedCalligraphy = null;
        let croppedCalligraphy = null;
        let currentStep = 1;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let currentPosition = { x: 50, y: 50 }; // í¼ì„¼íŠ¸
        let currentScale = 0.3; // ë°°ê²½ì˜ 30% í¬ê¸°ë¡œ ì‹œì‘ (ë” ì‘ê²Œ)
        let currentRotation = 0;
        let currentBlendMode = 'multiply';
        // cropAreaëŠ” ì´ì œ cropSystem.cropAreaë¡œ ê´€ë¦¬ë¨
        
        // DOM ìš”ì†Œ
        const steps = document.querySelectorAll('.step');
        const stepDots = document.querySelectorAll('.step-dot');
        const backgroundInput = document.getElementById('backgroundInput');
        const calligraphyInput = document.getElementById('calligraphyInput');
        const backgroundPreview = document.getElementById('backgroundPreview');
        const calligraphyPreview = document.getElementById('calligraphyPreview');
        const backgroundImageEl = document.getElementById('backgroundImage');
        const calligraphyImageEl = document.getElementById('calligraphyImage');
        const processedCalligraphyEl = document.getElementById('processedCalligraphy');
        const cropContainer = document.getElementById('cropContainer');
        const compositePreview = document.getElementById('compositePreview');
        const compositeBackground = document.getElementById('compositeBackground');
        const compositeCalligraphy = document.getElementById('compositeCalligraphy');
        const calligraphyOverlay = document.getElementById('calligraphyOverlay');
        const scaleSlider = document.getElementById('scaleSlider');
        const rotationSlider = document.getElementById('rotationSlider');
        const scaleValue = document.getElementById('scaleValue');
        const rotationValue = document.getElementById('rotationValue');
        const multiplyMode = document.getElementById('multiplyMode');
        const screenMode = document.getElementById('screenMode');
        const customModal = document.getElementById('customModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalConfirm = document.getElementById('modalConfirm');
        const modalCancel = document.getElementById('modalCancel');
        
        // ì´ë¯¸ì§€ ì••ì¶• í•¨ìˆ˜
        function compressImage(file, maxWidth = 1200, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
                    canvas.width = img.width * ratio;
                    canvas.height = img.height * ratio;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    canvas.toBlob(resolve, 'image/jpeg', quality);
                };
                
                img.src = URL.createObjectURL(file);
            });
        }
        
        // ì´ë¯¸ì§€ ìë™ ë³´ì • í•¨ìˆ˜ (í‘ë°±, ëŒ€ë¹„ 100%)
        function processCalligraphyImage(imageData) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // ì›ë³¸ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                    ctx.drawImage(img, 0, 0);
                    
                    // ì´ë¯¸ì§€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // í‘ë°± ë³€í™˜ ë° ëŒ€ë¹„ ì¡°ì •
                    for (let i = 0; i < data.length; i += 4) {
                        // ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ê³„ì‚°
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        
                        // ëŒ€ë¹„ 100% ì ìš© (0 ë˜ëŠ” 255)
                        const contrast = gray > 128 ? 255 : 0;
                        
                        data[i] = contrast;     // R
                        data[i + 1] = contrast; // G
                        data[i + 2] = contrast; // B
                        // data[i + 3]ëŠ” alpha ì±„ë„ì´ë¯€ë¡œ ê·¸ëŒ€ë¡œ ìœ ì§€
                    }
                    
                    // ì²˜ë¦¬ëœ ì´ë¯¸ì§€ ë°ì´í„° ì ìš©
                    ctx.putImageData(imageData, 0, 0);
                    
                    // ê²°ê³¼ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
                    canvas.toBlob(resolve, 'image/png');
                };
                
                img.src = imageData;
            });
        }
        
        // ëª¨ë‹¬ í‘œì‹œ í•¨ìˆ˜
        function showModal(title, message, showCancel = false) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalCancel.style.display = showCancel ? 'inline-block' : 'none';
            customModal.style.display = 'flex';
        }
        
        // ëª¨ë‹¬ ë‹«ê¸° í•¨ìˆ˜
        function closeModal() {
            customModal.style.display = 'none';
        }
        
        // ë’¤ë¡œê°€ê¸° í•¨ìˆ˜
        function goBack() {
            if (currentStep > 1) {
                currentStep--;
                showStep(currentStep);
                
                // 2ë‹¨ê³„ì—ì„œ 1ë‹¨ê³„ë¡œ ê°ˆ ë•Œ ì—…ë¡œë“œ ì˜ì—­ ë‹¤ì‹œ í‘œì‹œ
                if (currentStep === 1) {
                    const uploadAreas = document.querySelectorAll('.file-upload-area');
                    uploadAreas.forEach(area => {
                        area.style.display = 'block';
                    });
                    const previews = document.querySelectorAll('#backgroundPreview, #calligraphyPreview');
                    previews.forEach(preview => {
                        preview.style.display = 'none';
                    });
                }
            }
        }
        
        // ë‹¨ê³„ í‘œì‹œ í•¨ìˆ˜
        function showStep(step) {
            steps.forEach((s, index) => {
                s.classList.toggle('active', index + 1 === step);
            });
            
            // ëª¨ë“  ë‹¨ê³„ì˜ ì ë“¤ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.step-indicator').forEach(stepIndicator => {
                const dots = stepIndicator.querySelectorAll('.step-dot');
                dots.forEach((dot, index) => {
                    // ëª¨ë“  í´ë˜ìŠ¤ ì œê±°
                    dot.classList.remove('active', 'completed');
                    
                    // í˜„ì¬ ë‹¨ê³„ë§Œ active (í°ìƒ‰), ë‚˜ë¨¸ì§€ëŠ” ê¸°ë³¸ ìƒíƒœ (í°ìƒ‰ íˆ¬ëª…ë„ 50%)
                    if (index + 1 === step) {
                        dot.classList.add('active');
                    }
                });
            });
            
            // ë’¤ë¡œê°€ê¸° ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
            document.querySelector('.back-button').style.display = step > 1 ? 'block' : 'none';
            
            // ê° ë‹¨ê³„ë³„ ì´ˆê¸°í™”
            if (step === 3) {
                // í¬ë¡­ ì˜ì—­ ì´ˆê¸°í™”
                setTimeout(() => {
                    initCropArea();
                }, 100);
            } else if (step === 4) {
                updateCompositePreview();
            }
        }
        
        // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™
        function nextStep() {
            if (currentStep < 4) {
                currentStep++;
                showStep(currentStep);
            }
        }
        
        // ì´ì „ ë‹¨ê³„ë¡œ ì´ë™
        function prevStep() {
            if (currentStep > 1) {
                currentStep--;
                showStep(currentStep);
            }
        }
        
        // ìƒˆë¡œìš´ ì •í™•í•œ ì´ë¯¸ì§€ í¬ë¡­ ì‹œìŠ¤í…œ
        class PreciseCropSystem {
            constructor() {
                this.cropArea = { x: 10, y: 10, width: 80, height: 80 };
                this.isDragging = false;
                this.isResizing = false;
                this.resizeHandle = null;
                this.startPos = { x: 0, y: 0 };
                this.startCropArea = { x: 0, y: 0, width: 0, height: 0 };
            }

            // ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ ê³„ì‚° (CSS object-fit: contain ê³ ë ¤)
            getImageDisplayBounds(imgElement) {
                const imgRect = imgElement.getBoundingClientRect();
                
                // CSS object-fit: containìœ¼ë¡œ ì¸í•œ ì‹¤ì œ ì´ë¯¸ì§€ ì˜ì—­ ê³„ì‚°
                const imgAspectRatio = imgElement.naturalWidth / imgElement.naturalHeight;
                const containerAspectRatio = imgRect.width / imgRect.height;
                
                let actualWidth, actualHeight, offsetX, offsetY;
                
                if (containerAspectRatio > imgAspectRatio) {
                    // ì»¨í…Œì´ë„ˆê°€ ë” ë„“ìŒ - ì´ë¯¸ì§€ê°€ ì„¸ë¡œë¡œ ë§ì¶°ì§
                    actualHeight = imgRect.height;
                    actualWidth = imgRect.height * imgAspectRatio;
                    offsetX = (imgRect.width - actualWidth) / 2;
                    offsetY = 0;
                } else {
                    // ì»¨í…Œì´ë„ˆê°€ ë” ë†’ìŒ - ì´ë¯¸ì§€ê°€ ê°€ë¡œë¡œ ë§ì¶°ì§
                    actualWidth = imgRect.width;
                    actualHeight = imgRect.width / imgAspectRatio;
                    offsetX = 0;
                    offsetY = (imgRect.height - actualHeight) / 2;
                }
                
                const bounds = {
                    x: imgRect.left + offsetX,
                    y: imgRect.top + offsetY,
                    width: actualWidth,
                    height: actualHeight,
                    offsetX,
                    offsetY,
                    // ì¶”ê°€ ì •ë³´: ì›ë³¸ ì´ë¯¸ì§€ í¬ê¸°ì™€ ì»¨í…Œì´ë„ˆ í¬ê¸°
                    originalWidth: imgElement.naturalWidth,
                    originalHeight: imgElement.naturalHeight,
                    containerWidth: imgRect.width,
                    containerHeight: imgRect.height,
                    aspectRatio: imgAspectRatio,
                    containerAspectRatio: containerAspectRatio
                };
                
                console.log('ì´ë¯¸ì§€ í‘œì‹œ ì˜ì—­ (ê°œì„ ë¨):', bounds);
                return bounds;
            }

            // í”½ì…€ ì¢Œí‘œë¥¼ ì›ë³¸ ì´ë¯¸ì§€ ì¢Œí‘œë¡œ ë³€í™˜
            pixelToImageCoords(pixelX, pixelY, imgElement, displayBounds) {
                const scaleX = imgElement.naturalWidth / displayBounds.width;
                const scaleY = imgElement.naturalHeight / displayBounds.height;
                
                const imageX = (pixelX - displayBounds.x) * scaleX;
                const imageY = (pixelY - displayBounds.y) * scaleY;
                
                return { x: imageX, y: imageY };
            }

            // ì›ë³¸ ì´ë¯¸ì§€ ì¢Œí‘œë¥¼ í”½ì…€ ì¢Œí‘œë¡œ ë³€í™˜
            imageToPixelCoords(imageX, imageY, imgElement, displayBounds) {
                const scaleX = displayBounds.width / imgElement.naturalWidth;
                const scaleY = displayBounds.height / imgElement.naturalHeight;
                
                const pixelX = displayBounds.x + imageX * scaleX;
                const pixelY = displayBounds.y + imageY * scaleY;
                
                return { x: pixelX, y: pixelY };
            }

            // ì •í™•í•œ ì´ë¯¸ì§€ í¬ë¡­
            async cropImage(imageData, cropArea) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = () => {
                        const displayImg = document.getElementById('processedCalligraphy');
                        const displayBounds = this.getImageDisplayBounds(displayImg);
                        
                        // í¬ë¡­ ì˜ì—­ì„ í”½ì…€ ì¢Œí‘œë¡œ ë³€í™˜
                        const cropX = (cropArea.x / 100) * displayBounds.width;
                        const cropY = (cropArea.y / 100) * displayBounds.height;
                        const cropWidth = (cropArea.width / 100) * displayBounds.width;
                        const cropHeight = (cropArea.height / 100) * displayBounds.height;
                        
                        // ì›ë³¸ ì´ë¯¸ì§€ ì¢Œí‘œë¡œ ë³€í™˜
                        const sourceCoords = this.pixelToImageCoords(
                            displayBounds.x + cropX, 
                            displayBounds.y + cropY, 
                            img, 
                            displayBounds
                        );
                        
                        const sourceEndCoords = this.pixelToImageCoords(
                            displayBounds.x + cropX + cropWidth, 
                            displayBounds.y + cropY + cropHeight, 
                            img, 
                            displayBounds
                        );
                        
                        const sourceX = Math.max(0, Math.min(img.naturalWidth, sourceCoords.x));
                        const sourceY = Math.max(0, Math.min(img.naturalHeight, sourceCoords.y));
                        const sourceWidth = Math.max(1, Math.min(img.naturalWidth - sourceX, sourceEndCoords.x - sourceX));
                        const sourceHeight = Math.max(1, Math.min(img.naturalHeight - sourceY, sourceEndCoords.y - sourceY));
                        
                        // í¬ë¡­ëœ ì´ë¯¸ì§€ í¬ê¸° ì„¤ì •
                        canvas.width = sourceWidth;
                        canvas.height = sourceHeight;
                        
                        // ì´ë¯¸ì§€ í¬ë¡­
                        ctx.drawImage(
                            img,
                            sourceX, sourceY, sourceWidth, sourceHeight,
                            0, 0, sourceWidth, sourceHeight
                        );
                        
                        console.log('ì •í™•í•œ í¬ë¡­ ì •ë³´:', {
                            cropArea,
                            displayBounds,
                            sourceCoords: { x: sourceX, y: sourceY, width: sourceWidth, height: sourceHeight },
                            originalSize: { width: img.naturalWidth, height: img.naturalHeight }
                        });
                        
                        canvas.toBlob(resolve, 'image/png');
                    };
                    
                    img.src = imageData;
                });
            }

            // í¬ë¡­ í•¸ë“¤ ì—…ë°ì´íŠ¸
            updateCropHandles() {
                const img = document.getElementById('processedCalligraphy');
                const cropAreaEl = document.getElementById('cropArea');
                if (!img || !cropAreaEl) {
                    console.log('ì´ë¯¸ì§€ ë˜ëŠ” í¬ë¡­ ì˜ì—­ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                    return;
                }
                
                const displayBounds = this.getImageDisplayBounds(img);
                
                // í¬ë¡­ ì˜ì—­ì„ ì´ë¯¸ì§€ ì»¨í…Œì´ë„ˆ ê¸°ì¤€ ìƒëŒ€ ì¢Œí‘œë¡œ ë³€í™˜
                const imgContainer = img.parentElement;
                const containerRect = imgContainer.getBoundingClientRect();
                
                // ì´ë¯¸ì§€ ì»¨í…Œì´ë„ˆ ë‚´ì—ì„œì˜ ìƒëŒ€ ìœ„ì¹˜ ê³„ì‚° (ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ ê¸°ì¤€)
                const imageOffsetX = displayBounds.x - containerRect.left;
                const imageOffsetY = displayBounds.y - containerRect.top;
                
                const relativeX = imageOffsetX + (this.cropArea.x / 100) * displayBounds.width;
                const relativeY = imageOffsetY + (this.cropArea.y / 100) * displayBounds.height;
                const width = (this.cropArea.width / 100) * displayBounds.width;
                const height = (this.cropArea.height / 100) * displayBounds.height;
                
                console.log('í¬ë¡­ ì˜ì—­ ì—…ë°ì´íŠ¸:', {
                    cropArea: this.cropArea,
                    relativeCoords: { x: relativeX, y: relativeY, width, height },
                    displayBounds,
                    containerRect,
                    imageOffset: { x: imageOffsetX, y: imageOffsetY }
                });
                
                // í¬ë¡­ ì˜ì—­ì´ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì— ìˆëŠ”ì§€ í™•ì¸
                console.log('í¬ë¡­ ì˜ì—­ ìš”ì†Œ:', cropAreaEl);
                console.log('í¬ë¡­ ì˜ì—­ ìŠ¤íƒ€ì¼:', {
                    left: cropAreaEl.style.left,
                    top: cropAreaEl.style.top,
                    width: cropAreaEl.style.width,
                    height: cropAreaEl.style.height
                });
                
                // í¬ë¡­ ì˜ì—­ ì—…ë°ì´íŠ¸ (ìƒëŒ€ ì¢Œí‘œ ì‚¬ìš©)
                cropAreaEl.style.left = relativeX + 'px';
                cropAreaEl.style.top = relativeY + 'px';
                cropAreaEl.style.width = width + 'px';
                cropAreaEl.style.height = height + 'px';
                
                // í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                this.updateHandles(cropAreaEl);
            }

            // í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (í¬ë¡­ ì‚¬ê°í˜•ì— ì •í™•íˆ ë¶™ì´ê¸°)
            updateHandles(cropAreaEl) {
                // ê¸°ì¡´ í•¸ë“¤ ì œê±°
                const existingHandles = cropAreaEl.querySelectorAll('.crop-handle');
                existingHandles.forEach(handle => handle.remove());
                
                // 8ê°œ í•¸ë“¤ ë™ì  ìƒì„±
                const directions = ['nw', 'ne', 'sw', 'se', 'n', 's', 'w', 'e'];
                directions.forEach(direction => {
                    const handle = document.createElement('div');
                    handle.className = `crop-handle ${direction}`;
                    handle.dataset.direction = direction;
                    cropAreaEl.appendChild(handle);
                });
                
                // í•¸ë“¤ ìœ„ì¹˜ ì„¤ì •
                const handles = cropAreaEl.querySelectorAll('.crop-handle');
                handles.forEach(handle => {
                    const direction = handle.dataset.direction;
                    
                    // ëª¨ë“  í•¸ë“¤ì˜ ê¸°ë³¸ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
                    handle.style.left = 'auto';
                    handle.style.right = 'auto';
                    handle.style.top = 'auto';
                    handle.style.bottom = 'auto';
                    handle.style.transform = 'none';
                    
                    switch(direction) {
                        case 'nw':
                            handle.style.left = '-10px';
                            handle.style.top = '-10px';
                            break;
                        case 'ne':
                            handle.style.right = '-10px';
                            handle.style.top = '-10px';
                            break;
                        case 'sw':
                            handle.style.left = '-10px';
                            handle.style.bottom = '-10px';
                            break;
                        case 'se':
                            handle.style.right = '-10px';
                            handle.style.bottom = '-10px';
                            break;
                        case 'n':
                            handle.style.left = '50%';
                            handle.style.top = '-10px';
                            handle.style.transform = 'translateX(-50%)';
                            break;
                        case 's':
                            handle.style.left = '50%';
                            handle.style.bottom = '-10px';
                            handle.style.transform = 'translateX(-50%)';
                            break;
                        case 'w':
                            handle.style.left = '-10px';
                            handle.style.top = '50%';
                            handle.style.transform = 'translateY(-50%)';
                            break;
                        case 'e':
                            handle.style.right = '-10px';
                            handle.style.top = '50%';
                            handle.style.transform = 'translateY(-50%)';
                            break;
                    }
                });
                
                // í•¸ë“¤ ì´ë²¤íŠ¸ ì„¤ì •
                this.setupHandleEvents(handles);
            }
            
            // í•¸ë“¤ ì´ë²¤íŠ¸ ì„¤ì •
            setupHandleEvents(handles) {
                const img = document.getElementById('processedCalligraphy');
                
                handles.forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        console.log('í¬ë¡­ í•¸ë“¤ ë“œë˜ê·¸ ì‹œì‘:', handle.dataset.direction);
                        this.isResizing = true;
                        this.resizeHandle = handle.dataset.direction;
                        this.startPos = { x: e.clientX, y: e.clientY };
                        this.startCropArea = { ...this.cropArea };
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
            }
        }

        // ì „ì—­ í¬ë¡­ ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤
        const cropSystem = new PreciseCropSystem();
        
        // í•©ì„± ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
        function updateCompositePreview() {
            if (!backgroundImage) return;
            
            const compositeBackground = document.getElementById('compositeBackground');
            const compositeCalligraphy = document.getElementById('compositeCalligraphy');
            
            if (compositeBackground) {
                compositeBackground.src = backgroundImage;
                
                // ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ í›„ ë¹„ìœ¨ì— ë”°ë¼ ì¡°ì •
                compositeBackground.onload = () => {
                    adjustBackgroundImageSize(compositeBackground);
                };
            }
            
            if (compositeCalligraphy) {
                // í¬ë¡­ëœ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ì›ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©
                if (croppedCalligraphy) {
                    console.log('í¬ë¡­ëœ ì´ë¯¸ì§€ ì‚¬ìš©:', croppedCalligraphy);
                    compositeCalligraphy.src = croppedCalligraphy;
                } else if (calligraphyImage) {
                    console.log('ì›ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©:', calligraphyImage);
                    compositeCalligraphy.src = calligraphyImage;
                }
                
                compositeCalligraphy.onload = () => {
                    setTimeout(() => {
                        updateEditHandles();
                    }, 100);
                };
            }
            
            compositeSystem.updatePreview();
        }
        
        // ë°°ê²½ ì´ë¯¸ì§€ í¬ê¸° ìë™ ì¡°ì • í•¨ìˆ˜ (í¬ë¡­ê³¼ í•©ì„±ì—ì„œ ë™ì¼í•œ ë°©ì‹ ì ìš©)
        function adjustBackgroundImageSize(imgElement) {
            const container = imgElement.parentElement;
            const containerRect = container.getBoundingClientRect();
            
            // ì»¨í…Œì´ë„ˆì˜ ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨
            const containerAspectRatio = containerRect.width / containerRect.height;
            // ì´ë¯¸ì§€ì˜ ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨
            const imageAspectRatio = imgElement.naturalWidth / imgElement.naturalHeight;
            
            console.log('ë¹„ìœ¨ ë¹„êµ:', {
                container: containerAspectRatio,
                image: imageAspectRatio,
                containerSize: { width: containerRect.width, height: containerRect.height },
                imageSize: { width: imgElement.naturalWidth, height: imgElement.naturalHeight }
            });
            
            // ëª¨ë“  ê²½ìš°ì— object-fit: containì„ ì‚¬ìš©í•˜ì—¬ ì¼ê´€ì„± ë³´ì¥
            imgElement.style.width = '100%';
            imgElement.style.height = '100%';
            imgElement.style.maxWidth = '100%';
            imgElement.style.maxHeight = '100%';
            imgElement.style.objectFit = 'contain';
            imgElement.style.objectPosition = 'center';
            
            console.log('ì¼ê´€ëœ ì´ë¯¸ì§€ í‘œì‹œ ë°©ì‹ ì ìš© - object-fit: contain');
        }
        
        // ê¸€ì”¨ ì´ë¯¸ì§€ì˜ ì‹¤ì œ ìë¥¸ ëª¨ì–‘ ê°ì§€í•˜ì—¬ ë¼ì¸ ìƒì„± (calligraphyOverlay ê¸°ì¤€)
        function createCropOutline() {
            // ê¸°ì¡´ í¬ë¡­ ì•„ì›ƒë¼ì¸ ì œê±°
            const existingOutline = document.querySelector('.crop-outline');
            if (existingOutline) {
                existingOutline.remove();
            }
            
            // calligraphyOverlayì™€ ë™ì¼í•œ í¬ê¸°ë¡œ ì•„ì›ƒë¼ì¸ ìƒì„±
            const calligraphyOverlay = document.getElementById('calligraphyOverlay');
            if (!calligraphyOverlay) return;
            
            const outline = document.createElement('div');
            outline.className = 'crop-outline';
            
            // calligraphyOverlayì˜ ìœ„ì¹˜ì™€ í¬ê¸°ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            const overlayRect = calligraphyOverlay.getBoundingClientRect();
            const previewRect = document.getElementById('compositePreview').getBoundingClientRect();
            
            const relativeLeft = overlayRect.left - previewRect.left;
            const relativeTop = overlayRect.top - previewRect.top;
            
            outline.style.left = relativeLeft + 'px';
            outline.style.top = relativeTop + 'px';
            outline.style.width = overlayRect.width + 'px';
            outline.style.height = overlayRect.height + 'px';
            
            // calligraphyOverlayì™€ ë™ì¼í•œ transform ì ìš©
            const overlayTransform = calligraphyOverlay.style.transform;
            if (overlayTransform) {
                outline.style.transform = overlayTransform;
            }
            
            // composite-previewì— ì¶”ê°€
            document.getElementById('compositePreview').appendChild(outline);
            
            console.log('í¬ë¡­ ì•„ì›ƒë¼ì¸ ìƒì„± (calligraphyOverlay ê¸°ì¤€):', {
                left: relativeLeft,
                top: relativeTop,
                width: overlayRect.width,
                height: overlayRect.height,
                transform: overlayTransform
            });
        }
        
        // í¬ë¡­ëœ ì´ë¯¸ì§€ì˜ ì‹¤ì œ ë‚´ìš© ì˜ì—­ ê°ì§€
        function detectContentBounds(imageSrc) {
            return new Promise((resolve) => {
                if (!imageSrc) {
                    resolve({ x: 0, y: 0, width: 100, height: 100 });
                    return;
                }
                
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
                    let hasContent = false;
                    
                    // í”½ì…€ì„ ìŠ¤ìº”í•˜ì—¬ ì‹¤ì œ ë‚´ìš©ì´ ìˆëŠ” ì˜ì—­ ì°¾ê¸°
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const index = (y * canvas.width + x) * 4;
                            const alpha = data[index + 3];
                            
                            if (alpha > 0) { // íˆ¬ëª…í•˜ì§€ ì•Šì€ í”½ì…€
                                hasContent = true;
                                minX = Math.min(minX, x);
                                minY = Math.min(minY, y);
                                maxX = Math.max(maxX, x);
                                maxY = Math.max(maxY, y);
                            }
                        }
                    }
                    
                    if (hasContent) {
                        // í¼ì„¼íŠ¸ë¡œ ë³€í™˜
                        const bounds = {
                            x: (minX / canvas.width) * 100,
                            y: (minY / canvas.height) * 100,
                            width: ((maxX - minX) / canvas.width) * 100,
                            height: ((maxY - minY) / canvas.height) * 100
                        };
                        resolve(bounds);
                    } else {
                        resolve({ x: 0, y: 0, width: 100, height: 100 });
                    }
                };
                img.src = imageSrc;
            });
        }

        // í¸ì§‘ í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (compositePreview ë‚´ë¶€ì— ìœ„ì¹˜)
        function updateEditHandles() {
            const editHandles = document.getElementById('editHandles');
            const calligraphyOverlay = document.getElementById('calligraphyOverlay');
            if (!editHandles || !calligraphyOverlay) return;
            
            console.log('í¸ì§‘ í•¸ë“¤ ì—…ë°ì´íŠ¸ ì‹œì‘ - compositePreview ë‚´ë¶€');
            
            // calligraphyOverlayì™€ ë™ì¼í•œ CSS ì†ì„± ì ìš©
            editHandles.style.left = calligraphyOverlay.style.left;
            editHandles.style.top = calligraphyOverlay.style.top;
            editHandles.style.width = calligraphyOverlay.style.width;
            editHandles.style.height = calligraphyOverlay.style.height;
            editHandles.style.transform = calligraphyOverlay.style.transform;
            editHandles.style.display = 'block';
            
            // í¬ë¡­ëœ ì´ë¯¸ì§€ì˜ ì‹¤ì œ ë‚´ìš© ì˜ì—­ì— ë§ì¶° í¸ì§‘ í•¸ë“¤ í¬ê¸° ì¡°ì •
            if (croppedCalligraphy) {
                detectContentBounds(croppedCalligraphy).then((bounds) => {
                    console.log('í¬ë¡­ëœ ì´ë¯¸ì§€ ë‚´ìš© ì˜ì—­:', bounds);
                    
                    // í¸ì§‘ í•¸ë“¤ì˜ í¬ê¸°ë¥¼ ì‹¤ì œ ë‚´ìš© ì˜ì—­ì— ë§ì¶° ì¡°ì •
                    const contentX = (bounds.x / 100) * 100; // calligraphyOverlayì˜ 100% ê¸°ì¤€
                    const contentY = (bounds.y / 100) * 100;
                    const contentWidth = (bounds.width / 100) * 100;
                    const contentHeight = (bounds.height / 100) * 100;
                    
                    // í¸ì§‘ í•¸ë“¤ ì»¨í…Œì´ë„ˆ í¬ê¸° ì¡°ì •
                    editHandles.style.left = `calc(${calligraphyOverlay.style.left} + ${contentX}%)`;
                    editHandles.style.top = `calc(${calligraphyOverlay.style.top} + ${contentY}%)`;
                    editHandles.style.width = `${contentWidth}%`;
                    editHandles.style.height = `${contentHeight}%`;
                });
            }
            
            // í•¸ë“¤ ìœ„ì¹˜ ì¡°ì • (ê³ ì • í¬ê¸° ìœ ì§€)
            const scaleHandle = document.getElementById('scaleHandle');
            const rotateHandle = document.getElementById('rotateHandle');
            
            if (scaleHandle) {
                scaleHandle.style.right = '-20px';
                scaleHandle.style.bottom = '-20px';
                scaleHandle.style.width = '40px !important';
                scaleHandle.style.height = '40px !important';
                scaleHandle.style.minWidth = '40px !important';
                scaleHandle.style.minHeight = '40px !important';
                scaleHandle.style.maxWidth = '40px !important';
                scaleHandle.style.maxHeight = '40px !important';
                scaleHandle.style.transform = 'none !important';
            }
            
            if (rotateHandle) {
                rotateHandle.style.right = '-20px';
                rotateHandle.style.top = '-20px';
                rotateHandle.style.width = '40px !important';
                rotateHandle.style.height = '40px !important';
                rotateHandle.style.minWidth = '40px !important';
                rotateHandle.style.minHeight = '40px !important';
                rotateHandle.style.maxWidth = '40px !important';
                rotateHandle.style.maxHeight = '40px !important';
                rotateHandle.style.transform = 'none !important';
            }
            
            console.log('í¸ì§‘ í•¸ë“¤ ì—…ë°ì´íŠ¸ ì™„ë£Œ - compositePreview ë‚´ë¶€ì— ìœ„ì¹˜');
        }
        
        
        // ìƒˆë¡œìš´ ì •í™•í•œ í•©ì„± ì‹œìŠ¤í…œ
        class PreciseCompositeSystem {
            constructor() {
                this.position = { x: 50, y: 50 }; // í¼ì„¼íŠ¸ ë‹¨ìœ„
                this.scale = 0.3; // ë°°ê²½ì˜ 30% í¬ê¸°ë¡œ ì‹œì‘ (ë” ì‘ê²Œ)
                this.rotation = 0;
                this.blendMode = 'multiply';
                this.bounds = { x: 0, y: 0, width: 100, height: 100 }; // ê¸€ì”¨ì˜ ì‹¤ì œ ê²½ê³„
                this.backgroundDisplayBounds = null; // ë°°ê²½ ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­
            }

            // ë°°ê²½ ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ ê³„ì‚° (í¬ë¡­ ì‹œìŠ¤í…œê³¼ ë™ì¼í•œ ë°©ì‹)
            getBackgroundDisplayBounds(imgElement) {
                const imgRect = imgElement.getBoundingClientRect();
                
                // CSS object-fit: containìœ¼ë¡œ ì¸í•œ ì‹¤ì œ ì´ë¯¸ì§€ ì˜ì—­ ê³„ì‚°
                const imgAspectRatio = imgElement.naturalWidth / imgElement.naturalHeight;
                const containerAspectRatio = imgRect.width / imgRect.height;
                
                let actualWidth, actualHeight, offsetX, offsetY;
                
                if (containerAspectRatio > imgAspectRatio) {
                    // ì»¨í…Œì´ë„ˆê°€ ë” ë„“ìŒ - ì´ë¯¸ì§€ê°€ ì„¸ë¡œë¡œ ë§ì¶°ì§
                    actualHeight = imgRect.height;
                    actualWidth = imgRect.height * imgAspectRatio;
                    offsetX = (imgRect.width - actualWidth) / 2;
                    offsetY = 0;
                } else {
                    // ì»¨í…Œì´ë„ˆê°€ ë” ë†’ìŒ - ì´ë¯¸ì§€ê°€ ê°€ë¡œë¡œ ë§ì¶°ì§
                    actualWidth = imgRect.width;
                    actualHeight = imgRect.width / imgAspectRatio;
                    offsetX = 0;
                    offsetY = (imgRect.height - actualHeight) / 2;
                }
                
                const bounds = {
                    x: imgRect.left + offsetX,
                    y: imgRect.top + offsetY,
                    width: actualWidth,
                    height: actualHeight,
                    offsetX,
                    offsetY,
                    originalWidth: imgElement.naturalWidth,
                    originalHeight: imgElement.naturalHeight,
                    containerWidth: imgRect.width,
                    containerHeight: imgRect.height,
                    aspectRatio: imgAspectRatio,
                    containerAspectRatio: containerAspectRatio
                };
                
                console.log('ë°°ê²½ ì´ë¯¸ì§€ í‘œì‹œ ì˜ì—­:', bounds);
                return bounds;
            }

            // ì˜ë¼ì§„ ì´ë¯¸ì§€ì˜ ì‹¤ì œ ê²½ê³„ ê°ì§€
            detectImageBounds() {
                return new Promise((resolve) => {
                    if (!croppedCalligraphy) {
                        this.bounds = { x: 0, y: 0, width: 100, height: 100 };
                        resolve(this.bounds);
                        return;
                    }
                    
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        
                        ctx.drawImage(img, 0, 0);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
                        let hasContent = false;
                        
                        // í”½ì…€ì„ ìŠ¤ìº”í•˜ì—¬ ì‹¤ì œ ë‚´ìš©ì´ ìˆëŠ” ì˜ì—­ ì°¾ê¸°
                        for (let y = 0; y < canvas.height; y++) {
                            for (let x = 0; x < canvas.width; x++) {
                                const index = (y * canvas.width + x) * 4;
                                const alpha = data[index + 3];
                                
                                if (alpha > 0) { // íˆ¬ëª…í•˜ì§€ ì•Šì€ í”½ì…€
                                    hasContent = true;
                                    minX = Math.min(minX, x);
                                    minY = Math.min(minY, y);
                                    maxX = Math.max(maxX, x);
                                    maxY = Math.max(maxY, y);
                                }
                            }
                        }
                        
                        if (hasContent) {
                            // í¼ì„¼íŠ¸ë¡œ ë³€í™˜
                            this.bounds = {
                                x: (minX / canvas.width) * 100,
                                y: (minY / canvas.height) * 100,
                                width: ((maxX - minX) / canvas.width) * 100,
                                height: ((maxY - minY) / canvas.height) * 100
                            };
                        } else {
                            this.bounds = { x: 0, y: 0, width: 100, height: 100 };
                        }
                        
                        console.log('ì˜ë¼ì§„ ì´ë¯¸ì§€ ê²½ê³„ ê°ì§€:', this.bounds);
                        resolve(this.bounds);
                    };
                    img.src = croppedCalligraphy;
                });
            }

            // ë°°ê²½ ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ì— ë§ì¶° ê¸€ì”¨ ì´ë¯¸ì§€ í¬ê¸° ì¡°ì •
            adjustCalligraphyToBackground() {
                if (!this.backgroundDisplayBounds || !croppedCalligraphy) return;
                
                const calligraphyOverlay = document.getElementById('calligraphyOverlay');
                if (!calligraphyOverlay) return;
                
                // ë°°ê²½ ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ ë¹„ìœ¨ ê³„ì‚°
                const backgroundRatio = this.backgroundDisplayBounds.width / this.backgroundDisplayBounds.height;
                
                // í¬ë¡­ëœ ì´ë¯¸ì§€ì˜ ë¹„ìœ¨ ê³„ì‚°
                const img = new Image();
                img.onload = () => {
                    const calligraphyRatio = img.naturalWidth / img.naturalHeight;
                    
                    console.log('ë¹„ìœ¨ ë¹„êµ:', {
                        background: backgroundRatio,
                        calligraphy: calligraphyRatio,
                        backgroundBounds: this.backgroundDisplayBounds
                    });
                    
                    // ë°°ê²½ ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ì— ë§ì¶° ê¸€ì”¨ ì˜¤ë²„ë ˆì´ í¬ê¸° ì¡°ì •
                    if (backgroundRatio > calligraphyRatio) {
                        // ë°°ê²½ì´ ë” ë„“ìŒ - ê¸€ì”¨ë¥¼ ì„¸ë¡œë¡œ ë§ì¶¤
                        calligraphyOverlay.style.width = 'auto';
                        calligraphyOverlay.style.height = '100%';
                        calligraphyOverlay.style.maxWidth = '100%';
                        calligraphyOverlay.style.maxHeight = '100%';
                    } else {
                        // ë°°ê²½ì´ ë” ë†’ìŒ - ê¸€ì”¨ë¥¼ ê°€ë¡œë¡œ ë§ì¶¤
                        calligraphyOverlay.style.width = '100%';
                        calligraphyOverlay.style.height = 'auto';
                        calligraphyOverlay.style.maxWidth = '100%';
                        calligraphyOverlay.style.maxHeight = '100%';
                    }
                    
                    calligraphyOverlay.style.objectFit = 'contain';
                    calligraphyOverlay.style.objectPosition = 'center';
                    
                    console.log('ê¸€ì”¨ ì´ë¯¸ì§€ í¬ê¸° ì¡°ì • ì™„ë£Œ');
                };
                img.src = croppedCalligraphy;
            }

            // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸ (CSS Transform ì‚¬ìš©)
            updatePreview() {
                if (!backgroundImage) return;
                
                const compositeBackground = document.getElementById('compositeBackground');
                const compositeCalligraphy = document.getElementById('compositeCalligraphy');
                const calligraphyOverlay = document.getElementById('calligraphyOverlay');
                const editHandles = document.getElementById('editHandles');
                
                if (!compositeBackground || !compositeCalligraphy || !calligraphyOverlay) return;
                
                compositeBackground.src = backgroundImage;
                
                // ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ í›„ ë¹„ìœ¨ì— ë”°ë¼ ì¡°ì •
                compositeBackground.onload = () => {
                    adjustBackgroundImageSize(compositeBackground);
                    // ë°°ê²½ ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ ê³„ì‚° ë° ì €ì¥
                    this.backgroundDisplayBounds = this.getBackgroundDisplayBounds(compositeBackground);
                };
                
                // í¬ë¡­ëœ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ì›ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©
                if (croppedCalligraphy) {
                    console.log('compositeSystemì—ì„œ í¬ë¡­ëœ ì´ë¯¸ì§€ ì‚¬ìš©:', croppedCalligraphy);
                    compositeCalligraphy.src = croppedCalligraphy;
                } else if (calligraphyImage) {
                    console.log('compositeSystemì—ì„œ ì›ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©:', calligraphyImage);
                    compositeCalligraphy.src = calligraphyImage;
                } else {
                    return;
                }
                
                // ì˜ë¼ì§„ ì´ë¯¸ì§€ ê²½ê³„ ê°ì§€
                this.detectImageBounds().then(() => {
                    // ë°°ê²½ ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ì— ë§ì¶° ê¸€ì”¨ ì´ë¯¸ì§€ í¬ê¸° ì¡°ì •
                    this.adjustCalligraphyToBackground();
                    this.updateEditHandles();
                });
                
                // ìœ„ì¹˜, í¬ê¸°, íšŒì „ ì ìš©
                const transform = `translate(-50%, -50%) scale(${this.scale}) rotate(${this.rotation}deg)`;
                calligraphyOverlay.style.left = `${this.position.x}%`;
                calligraphyOverlay.style.top = `${this.position.y}%`;
                calligraphyOverlay.style.transform = transform;
                
                // í¸ì§‘ í•¸ë“¤ì„ calligraphyOverlayì™€ ì •í™•íˆ ë™ì¼í•œ ìœ„ì¹˜ì™€ í¬ê¸°ë¡œ ì„¤ì •
                if (editHandles) {
                    // calligraphyOverlayì™€ ë™ì¼í•œ CSS ì†ì„± ì ìš©
                    editHandles.style.left = calligraphyOverlay.style.left;
                    editHandles.style.top = calligraphyOverlay.style.top;
                    editHandles.style.width = calligraphyOverlay.style.width;
                    editHandles.style.height = calligraphyOverlay.style.height;
                    editHandles.style.transform = calligraphyOverlay.style.transform;
                }
                
                console.log('ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸:', {
                    position: this.position,
                    scale: this.scale,
                    rotation: this.rotation,
                    blendMode: this.blendMode,
                    bounds: this.bounds,
                    transform: transform
                });
                
                // ë¸”ë Œë“œ ëª¨ë“œ ì ìš©
                if (this.blendMode === 'screen') {
                    calligraphyOverlay.style.filter = 'invert(1)';
                    calligraphyOverlay.style.mixBlendMode = 'screen';
                } else {
                    calligraphyOverlay.style.filter = 'none';
                    calligraphyOverlay.style.mixBlendMode = 'multiply';
                }
            }
            
            // í¸ì§‘ í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (compositePreview ë‚´ë¶€ì— ìœ„ì¹˜)
            updateEditHandles() {
                const editHandles = document.getElementById('editHandles');
                const calligraphyOverlay = document.getElementById('calligraphyOverlay');
                if (!editHandles || !calligraphyOverlay) return;
                
                console.log('compositeSystem í¸ì§‘ í•¸ë“¤ ì—…ë°ì´íŠ¸ ì‹œì‘ - compositePreview ë‚´ë¶€');
                
                // calligraphyOverlayì™€ ë™ì¼í•œ CSS ì†ì„± ì ìš©
                editHandles.style.left = calligraphyOverlay.style.left;
                editHandles.style.top = calligraphyOverlay.style.top;
                editHandles.style.width = calligraphyOverlay.style.width;
                editHandles.style.height = calligraphyOverlay.style.height;
                editHandles.style.transform = calligraphyOverlay.style.transform;
                editHandles.style.display = 'block';
                
                // í¬ë¡­ëœ ì´ë¯¸ì§€ì˜ ì‹¤ì œ ë‚´ìš© ì˜ì—­ì— ë§ì¶° í¸ì§‘ í•¸ë“¤ í¬ê¸° ì¡°ì •
                if (croppedCalligraphy) {
                    detectContentBounds(croppedCalligraphy).then((bounds) => {
                        console.log('compositeSystem í¬ë¡­ëœ ì´ë¯¸ì§€ ë‚´ìš© ì˜ì—­:', bounds);
                        
                        // í¸ì§‘ í•¸ë“¤ì˜ í¬ê¸°ë¥¼ ì‹¤ì œ ë‚´ìš© ì˜ì—­ì— ë§ì¶° ì¡°ì •
                        const contentX = (bounds.x / 100) * 100; // calligraphyOverlayì˜ 100% ê¸°ì¤€
                        const contentY = (bounds.y / 100) * 100;
                        const contentWidth = (bounds.width / 100) * 100;
                        const contentHeight = (bounds.height / 100) * 100;
                        
                        // í¸ì§‘ í•¸ë“¤ ì»¨í…Œì´ë„ˆ í¬ê¸° ì¡°ì •
                        editHandles.style.left = `calc(${calligraphyOverlay.style.left} + ${contentX}%)`;
                        editHandles.style.top = `calc(${calligraphyOverlay.style.top} + ${contentY}%)`;
                        editHandles.style.width = `${contentWidth}%`;
                        editHandles.style.height = `${contentHeight}%`;
                    });
                }
                
                // í•¸ë“¤ í¬ê¸° ê³ ì •
                const scaleHandle = document.getElementById('scaleHandle');
                const rotateHandle = document.getElementById('rotateHandle');
                
                if (scaleHandle) {
                    scaleHandle.style.width = '40px !important';
                    scaleHandle.style.height = '40px !important';
                    scaleHandle.style.minWidth = '40px !important';
                    scaleHandle.style.minHeight = '40px !important';
                    scaleHandle.style.maxWidth = '40px !important';
                    scaleHandle.style.maxHeight = '40px !important';
                    scaleHandle.style.transform = 'none !important';
                }
                
                if (rotateHandle) {
                    rotateHandle.style.width = '40px !important';
                    rotateHandle.style.height = '40px !important';
                    rotateHandle.style.minWidth = '40px !important';
                    rotateHandle.style.minHeight = '40px !important';
                    rotateHandle.style.maxWidth = '40px !important';
                    rotateHandle.style.maxHeight = '40px !important';
                    rotateHandle.style.transform = 'none !important';
                }
                
                console.log('compositeSystem í¸ì§‘ í•¸ë“¤ ì—…ë°ì´íŠ¸ ì™„ë£Œ - compositePreview ë‚´ë¶€ì— ìœ„ì¹˜');
            }

            // ì •í™•í•œ ë‹¤ìš´ë¡œë“œ ì´ë¯¸ì§€ ìƒì„± (ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€ í¬ê¸°ì— ë§ì¶¤)
            async downloadImage() {
                return new Promise((resolve) => {
                    // ë¯¸ë¦¬ë³´ê¸° ì˜ì—­ì˜ ì •í™•í•œ í¬ê¸°ì™€ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
                    const previewElement = document.getElementById('compositePreview');
                    const calligraphyOverlay = document.getElementById('calligraphyOverlay');
                    const compositeBackground = document.getElementById('compositeBackground');
                    
                    if (!previewElement || !calligraphyOverlay || !compositeBackground) {
                        console.error('ë¯¸ë¦¬ë³´ê¸° ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                        resolve();
                        return;
                    }
                    
                    const previewRect = previewElement.getBoundingClientRect();
                    const overlayRect = calligraphyOverlay.getBoundingClientRect();
                    
                    // ë°°ê²½ ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ ê³„ì‚°
                    const backgroundBounds = this.getBackgroundDisplayBounds(compositeBackground);
                    
                    // ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€ í¬ê¸°ë¡œ ìº”ë²„ìŠ¤ ìƒì„±
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // ë°°ê²½ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                    const bgImg = new Image();
                    bgImg.onload = () => {
                        // ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€ í¬ê¸°ë¡œ ìº”ë²„ìŠ¤ ì„¤ì •
                        canvas.width = bgImg.naturalWidth;
                        canvas.height = bgImg.naturalHeight;
                        
                        // ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ì „ì²´ í¬ê¸°)
                        ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
                        
                        console.log('ë‹¤ìš´ë¡œë“œ ìº”ë²„ìŠ¤ í¬ê¸° (ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€):', {
                            width: canvas.width,
                            height: canvas.height,
                            originalSize: { width: bgImg.naturalWidth, height: bgImg.naturalHeight }
                        });
                        
                        // ê¸€ì”¨ ì˜¤ë²„ë ˆì´ ê·¸ë¦¬ê¸°
                        const calligraphyImg = new Image();
                        calligraphyImg.onload = () => {
                            ctx.save();
                            
                            // ë¯¸ë¦¬ë³´ê¸°ì—ì„œì˜ ê¸€ì”¨ ìœ„ì¹˜ì™€ í¬ê¸°ë¥¼ ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€ í¬ê¸°ë¡œ ë³€í™˜
                            const scaleX = canvas.width / backgroundBounds.width;
                            const scaleY = canvas.height / backgroundBounds.height;
                            
                            // ë¯¸ë¦¬ë³´ê¸°ì—ì„œì˜ ê¸€ì”¨ ì¤‘ì‹¬ì ì„ ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€ ì¢Œí‘œë¡œ ë³€í™˜
                            const previewCenterX = overlayRect.left - previewRect.left + overlayRect.width / 2;
                            const previewCenterY = overlayRect.top - previewRect.top + overlayRect.height / 2;
                            
                            // ë°°ê²½ ì´ë¯¸ì§€ì˜ ì‹¤ì œ í‘œì‹œ ì˜ì—­ ë‚´ì—ì„œì˜ ìƒëŒ€ ìœ„ì¹˜ ê³„ì‚°
                            const relativeX = (previewCenterX - backgroundBounds.offsetX) / backgroundBounds.width;
                            const relativeY = (previewCenterY - backgroundBounds.offsetY) / backgroundBounds.height;
                            
                            // ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€ì—ì„œì˜ ì‹¤ì œ ìœ„ì¹˜
                            const centerX = relativeX * canvas.width;
                            const centerY = relativeY * canvas.height;
                            
                            // ê¸€ì”¨ í¬ê¸°ë¥¼ ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€ì— ë§ê²Œ ì¡°ì •
                            const calligraphyWidth = overlayRect.width * scaleX;
                            const calligraphyHeight = overlayRect.height * scaleY;
                            
                            console.log('ë‹¤ìš´ë¡œë“œ ì´ë¯¸ì§€ ìƒì„± (ì›ë³¸ ë°°ê²½ í¬ê¸°):', {
                                canvasSize: { width: canvas.width, height: canvas.height },
                                backgroundBounds: backgroundBounds,
                                scaleFactors: { scaleX, scaleY },
                                previewCenter: { x: previewCenterX, y: previewCenterY },
                                relativePosition: { x: relativeX, y: relativeY },
                                finalCenter: { x: centerX, y: centerY },
                                calligraphySize: { width: calligraphyWidth, height: calligraphyHeight },
                                rotation: this.rotation,
                                blendMode: this.blendMode
                            });
                            
                            // íšŒì „ ì¤‘ì‹¬ì ìœ¼ë¡œ ì´ë™
                            ctx.translate(centerX, centerY);
                            ctx.rotate((this.rotation * Math.PI) / 180);
                            
                            // ë¸”ë Œë“œ ëª¨ë“œ ì„¤ì • (ë¯¸ë¦¬ë³´ê¸°ì™€ ë™ì¼)
                            if (this.blendMode === 'screen') {
                                ctx.globalCompositeOperation = 'screen';
                                ctx.filter = 'invert(1)';
                            } else {
                                ctx.globalCompositeOperation = 'multiply';
                                ctx.filter = 'none';
                            }
                            
                            // ì›ë³¸ ë°°ê²½ ì´ë¯¸ì§€ í¬ê¸°ì— ë§ì¶° ê¸€ì”¨ ê·¸ë¦¬ê¸° (ì¤‘ì‹¬ì  ê¸°ì¤€)
                            ctx.drawImage(calligraphyImg, -calligraphyWidth / 2, -calligraphyHeight / 2, calligraphyWidth, calligraphyHeight);
                            ctx.restore();
                            
                            // ë‹¤ìš´ë¡œë“œ
                            const link = document.createElement('a');
                            link.download = 'calligraphy-composite.jpg';
                            link.href = canvas.toDataURL('image/jpeg', 0.9);
                            link.click();
                            
                            resolve();
                        };
                        calligraphyImg.src = croppedCalligraphy;
                    };
                    bgImg.src = backgroundImage;
                });
            }

            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            updatePosition(x, y) {
                this.position.x = Math.max(0, Math.min(100, x));
                this.position.y = Math.max(0, Math.min(100, y));
                this.updatePreview();
            }

            // í¬ê¸° ì—…ë°ì´íŠ¸
            updateScale(scale) {
                this.scale = Math.max(0.1, Math.min(5, scale));
                this.updatePreview();
                this.updateEditHandles();
            }

            // íšŒì „ ì—…ë°ì´íŠ¸
            updateRotation(rotation) {
                this.rotation = rotation;
                this.updatePreview();
                this.updateEditHandles();
            }

            // ë¸”ë Œë“œ ëª¨ë“œ ì—…ë°ì´íŠ¸
            updateBlendMode(mode) {
                this.blendMode = mode;
                this.updatePreview();
            }
        }

        // ì „ì—­ í•©ì„± ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤
        const compositeSystem = new PreciseCompositeSystem();

        // ìµœì¢… ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ (ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©)
        function downloadFinalImage() {
            compositeSystem.downloadImage();
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        backgroundInput.addEventListener('change', async (e) => {
            console.log('ë°°ê²½ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹œì‘');
            const file = e.target.files[0];
            if (file) {
                console.log('íŒŒì¼ ì„ íƒë¨:', file.name);
                try {
                    const compressed = await compressImage(file);
                    backgroundImage = URL.createObjectURL(compressed);
                    backgroundImageEl.src = backgroundImage;
                    
                    // ì ì„  ì˜ì—­ì„ ì‚¬ì§„ìœ¼ë¡œ êµì²´
                    const uploadArea = document.querySelector('.file-upload-area');
                    uploadArea.style.display = 'none';
                    backgroundPreview.style.display = 'block';
                    
                    // ë‹¤ìŒ ë‹¨ê³„ ë²„íŠ¼ í‘œì‹œ
                    document.getElementById('nextButtonContainer').style.display = 'block';
                    
                    console.log('ë°°ê²½ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì™„ë£Œ');
                } catch (error) {
                    console.error('ë°°ê²½ ì´ë¯¸ì§€ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                }
            }
        });
        
        calligraphyInput.addEventListener('change', async (e) => {
            console.log('ê¸€ì”¨ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹œì‘');
            const file = e.target.files[0];
            if (file) {
                console.log('ê¸€ì”¨ íŒŒì¼ ì„ íƒë¨:', file.name);
                
                try {
                    const compressed = await compressImage(file);
                    calligraphyImage = URL.createObjectURL(compressed);
                    
                    // ì ì„  ì˜ì—­ì„ ì‚¬ì§„ìœ¼ë¡œ êµì²´
                    const uploadArea = calligraphyInput.closest('.file-upload-area');
                    if (uploadArea) {
                    uploadArea.style.display = 'none';
                    }
                    
                    console.log('ê¸€ì”¨ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì™„ë£Œ, ìë™ìœ¼ë¡œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™');
                    // ìë™ìœ¼ë¡œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™
                    setTimeout(async () => {
                        // ê¸€ì”¨ ì´ë¯¸ì§€ ìë™ ë³´ì • ì²˜ë¦¬
                        if (calligraphyImage) {
                            try {
                    const processed = await processCalligraphyImage(calligraphyImage);
                    processedCalligraphy = URL.createObjectURL(processed);
                    processedCalligraphyEl.src = processedCalligraphy;
                    
                    // ìƒˆë¡œìš´ í¬ë¡­ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                    setTimeout(() => {
                        initCropArea();
                        setupCropEvents();
                    }, 100);
                            } catch (error) {
                                console.error('ê¸€ì”¨ ì´ë¯¸ì§€ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                            }
                        }
                        nextStep();
                    }, 500); // 0.5ì´ˆ í›„ ìë™ ì´ë™
                } catch (error) {
                    console.error('ê¸€ì”¨ ì´ë¯¸ì§€ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                }
            }
        });
        
        
        // í¬ë¡­ í•¸ë“¤ ë“œë˜ê·¸ ì´ë²¤íŠ¸
        let isResizing = false;
        let isMoving = false;
        let resizeDirection = '';
        let startMousePos = { x: 0, y: 0 };
        let startCropArea = { x: 0, y: 0, width: 100, height: 100 };
        
        // í¬ë¡­ ì˜ì—­ ì´ˆê¸°í™” (ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©)
        function initCropArea() {
            cropSystem.cropArea = { x: 10, y: 10, width: 80, height: 80 };
            
            // ì´ë¯¸ì§€ê°€ ë¡œë“œëœ í›„ í¬ë¡­ í•¸ë“¤ ì—…ë°ì´íŠ¸
            setTimeout(() => {
                const cropAreaEl = document.getElementById('cropArea');
                if (cropAreaEl) {
                    cropSystem.updateCropHandles(cropAreaEl);
                }
            }, 100);
        }
        
        // í¬ë¡­ í•¸ë“¤ ì—…ë°ì´íŠ¸ (ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©)
        function updateCropHandles() {
            const cropAreaEl = document.getElementById('cropArea');
            if (cropAreaEl) {
                cropSystem.updateCropHandles(cropAreaEl);
            }
        }
        
        // ìƒˆë¡œìš´ ì •í™•í•œ í¬ë¡­ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
        function setupCropEvents() {
            const img = document.getElementById('processedCalligraphy');
            const cropAreaEl = document.getElementById('cropArea');
            
            if (!img || !cropAreaEl) {
                console.log('í¬ë¡­ ì´ë²¤íŠ¸ ì„¤ì • ì‹¤íŒ¨: ì´ë¯¸ì§€ ë˜ëŠ” í¬ë¡­ ì˜ì—­ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                return;
            }
            
            console.log('í¬ë¡­ ì´ë²¤íŠ¸ ì„¤ì • ì™„ë£Œ');
            
            // í¬ë¡­ í•¸ë“¤ ì´ë²¤íŠ¸ëŠ” updateHandlesì—ì„œ ì„¤ì •ë¨
            
            // í¬ë¡­ ì˜ì—­ ë“œë˜ê·¸ ì´ë²¤íŠ¸
            cropAreaEl.addEventListener('mousedown', (e) => {
                console.log('í¬ë¡­ ì˜ì—­ ë“œë˜ê·¸ ì‹œì‘');
                cropSystem.isDragging = true;
                cropSystem.startPos = { x: e.clientX, y: e.clientY };
                cropSystem.startCropArea = { ...cropSystem.cropArea };
                e.preventDefault();
                e.stopPropagation();
            });
            
            // ë§ˆìš°ìŠ¤ ì´ë™ ì´ë²¤íŠ¸
            document.addEventListener('mousemove', (e) => {
                if (cropSystem.isResizing) {
                    const displayBounds = cropSystem.getImageDisplayBounds(img);
                    const deltaX = ((e.clientX - cropSystem.startPos.x) / displayBounds.width) * 100;
                    const deltaY = ((e.clientY - cropSystem.startPos.y) / displayBounds.height) * 100;
                    
                    console.log('í¬ë¡­ ë¦¬ì‚¬ì´ì§•:', {
                        direction: cropSystem.resizeHandle,
                        deltaX, deltaY,
                        startPos: cropSystem.startPos,
                        currentPos: { x: e.clientX, y: e.clientY }
                    });
                    
                    let newCropArea = { ...cropSystem.startCropArea };
                    
                    // ë¦¬ì‚¬ì´ì§• ë°©í–¥ì— ë”°ë¥¸ ì²˜ë¦¬
                    switch(cropSystem.resizeHandle) {
                        case 'nw': // ì™¼ìª½ ìœ„
                            newCropArea.x = Math.max(0, cropSystem.startCropArea.x + deltaX);
                            newCropArea.y = Math.max(0, cropSystem.startCropArea.y + deltaY);
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width - deltaX);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height - deltaY);
                            break;
                        case 'ne': // ì˜¤ë¥¸ìª½ ìœ„
                            newCropArea.y = Math.max(0, cropSystem.startCropArea.y + deltaY);
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width + deltaX);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height - deltaY);
                            break;
                        case 'sw': // ì™¼ìª½ ì•„ë˜
                            newCropArea.x = Math.max(0, cropSystem.startCropArea.x + deltaX);
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width - deltaX);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height + deltaY);
                            break;
                        case 'se': // ì˜¤ë¥¸ìª½ ì•„ë˜
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width + deltaX);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height + deltaY);
                            break;
                        case 'n': // ìœ„
                            newCropArea.y = Math.max(0, cropSystem.startCropArea.y + deltaY);
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height - deltaY);
                            break;
                        case 's': // ì•„ë˜
                            newCropArea.height = Math.max(5, cropSystem.startCropArea.height + deltaY);
                            break;
                        case 'w': // ì™¼ìª½
                            newCropArea.x = Math.max(0, cropSystem.startCropArea.x + deltaX);
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width - deltaX);
                            break;
                        case 'e': // ì˜¤ë¥¸ìª½
                            newCropArea.width = Math.max(5, cropSystem.startCropArea.width + deltaX);
                            break;
                    }
                    
                    // ê²½ê³„ ì²´í¬
                    if (newCropArea.x + newCropArea.width > 100) {
                        newCropArea.width = 100 - newCropArea.x;
                    }
                    if (newCropArea.y + newCropArea.height > 100) {
                        newCropArea.height = 100 - newCropArea.y;
                    }
                    
                    cropSystem.cropArea = newCropArea;
                    cropSystem.updateCropHandles();
                } else if (cropSystem.isDragging) {
                    const displayBounds = cropSystem.getImageDisplayBounds(img);
                    const deltaX = ((e.clientX - cropSystem.startPos.x) / displayBounds.width) * 100;
                    const deltaY = ((e.clientY - cropSystem.startPos.y) / displayBounds.height) * 100;
                    
                    let newCropArea = { ...cropSystem.startCropArea };
                    newCropArea.x = Math.max(0, Math.min(100 - newCropArea.width, cropSystem.startCropArea.x + deltaX));
                    newCropArea.y = Math.max(0, Math.min(100 - newCropArea.height, cropSystem.startCropArea.y + deltaY));
                    
                    cropSystem.cropArea = newCropArea;
                    cropSystem.updateCropHandles();
                }
            });
            
            // ë§ˆìš°ìŠ¤ ì—… ì´ë²¤íŠ¸
            document.addEventListener('mouseup', () => {
                cropSystem.isResizing = false;
                cropSystem.isDragging = false;
            });
        }
        
        // í¸ì§‘ í•¸ë“¤ ë³€ìˆ˜
        let isEditing = false;
        let editType = '';
        let editStart = { x: 0, y: 0, scale: 1, rotation: 0 };
        
        // ìƒˆë¡œìš´ í•©ì„± ë¯¸ë¦¬ë³´ê¸° ë“œë˜ê·¸ ì´ë²¤íŠ¸
        calligraphyOverlay.addEventListener('mousedown', (e) => {
            // í¸ì§‘ í•¸ë“¤ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ìœ„ì¹˜ ì´ë™
            if (!e.target.classList.contains('edit-handle')) {
                isDragging = true;
                const rect = compositePreview.getBoundingClientRect();
                dragStart = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                e.preventDefault();
            }
        });
        
        // í¬ê¸° ì¡°ì • í•¸ë“¤
        document.getElementById('scaleHandle').addEventListener('mousedown', (e) => {
            isEditing = true;
            editType = 'scale';
            editStart = {
                x: e.clientX,
                y: e.clientY,
                scale: compositeSystem.scale,
                rotation: compositeSystem.rotation
            };
            e.preventDefault();
            e.stopPropagation();
        });
        
        // íšŒì „ í•¸ë“¤
        document.getElementById('rotateHandle').addEventListener('mousedown', (e) => {
            isEditing = true;
            editType = 'rotate';
            editStart = {
                x: e.clientX,
                y: e.clientY,
                scale: compositeSystem.scale,
                rotation: compositeSystem.rotation
            };
            e.preventDefault();
            e.stopPropagation();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = compositePreview.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const newX = Math.max(0, Math.min(100, ((x / rect.width) * 100)));
                const newY = Math.max(0, Math.min(100, ((y / rect.height) * 100)));
                
                compositeSystem.updatePosition(newX, newY);
            } else if (isEditing) {
                const deltaX = e.clientX - editStart.x;
                const deltaY = e.clientY - editStart.y;
                
                if (editType === 'scale') {
                    // í¬ê¸° ì¡°ì • (ëŒ€ê°ì„  ë°©í–¥ë§Œ, ê°ë„ ì¡°ì ˆ)
                    const diagonalDistance = (deltaX + deltaY) / Math.sqrt(2); // ëŒ€ê°ì„  ê±°ë¦¬
                    const scaleFactor = 1 + (diagonalDistance / 800); // ê°ë„ ì¡°ì ˆ
                    const newScale = Math.max(0.1, Math.min(2, editStart.scale * scaleFactor));
                    compositeSystem.updateScale(newScale);
                } else if (editType === 'rotate') {
                    // íšŒì „ ì¡°ì • (ì¤‘ì‹¬ì  ê¸°ì¤€, ê°ë„ ì¡°ì ˆ)
                    const centerX = editStart.x;
                    const centerY = editStart.y;
                    const startAngle = Math.atan2(editStart.y - centerY, editStart.x - centerX);
                    const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    const angleDiff = (currentAngle - startAngle) * (180 / Math.PI);
                    const rotationSensitivity = 0.3; // íšŒì „ ê°ë„ 50%ë¡œ ì¡°ì ˆ
                    const newRotation = editStart.rotation + (angleDiff * rotationSensitivity);
                    compositeSystem.updateRotation(newRotation);
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            isEditing = false;
        });
        
        // ë¸”ë Œë“œ ëª¨ë“œ ë²„íŠ¼ ì´ë²¤íŠ¸
        multiplyMode.addEventListener('click', () => {
            compositeSystem.updateBlendMode('multiply');
            multiplyMode.classList.add('active');
            screenMode.classList.remove('active');
        });
        
        screenMode.addEventListener('click', () => {
            compositeSystem.updateBlendMode('screen');
            screenMode.classList.add('active');
            multiplyMode.classList.remove('active');
        });
        
        // ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('nextToStep2').addEventListener('click', nextStep);
        document.getElementById('nextToStep4').addEventListener('click', async () => {
            // í¬ë¡­ëœ ì´ë¯¸ì§€ ìƒì„±
            if (processedCalligraphy) {
                croppedCalligraphy = await cropSystem.cropImage(processedCalligraphy, cropSystem.cropArea);
                croppedCalligraphy = URL.createObjectURL(croppedCalligraphy);
                
                console.log('í¬ë¡­ëœ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ:', croppedCalligraphy);
                
                // í¬ë¡­ ì™„ë£Œ í›„ í•©ì„± ì‹œìŠ¤í…œì˜ ê²½ê³„ ë‹¤ì‹œ ê°ì§€ ë° ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
                setTimeout(() => {
                    compositeSystem.detectImageBounds().then(() => {
                        updateCompositePreview();
                        // í¸ì§‘ í•¸ë“¤ ì—…ë°ì´íŠ¸ë¥¼ ë³„ë„ë¡œ í˜¸ì¶œ
                        setTimeout(() => {
                            updateEditHandles();
                        }, 200);
                    });
                }, 100);
            }
            nextStep();
        });
        document.getElementById('downloadBtn').addEventListener('click', downloadFinalImage);
        document.getElementById('restartBtn').addEventListener('click', () => {
            location.reload();
        });
        
        // íŒŒì¼ ë“œë˜ê·¸ ì•¤ ë“œë¡­
        document.querySelectorAll('.file-upload-area').forEach(area => {
            area.addEventListener('dragover', (e) => {
                e.preventDefault();
                area.classList.add('dragover');
            });
            
            area.addEventListener('dragleave', () => {
                area.classList.remove('dragover');
            });
            
            area.addEventListener('drop', async (e) => {
                e.preventDefault();
                area.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        // ë°°ê²½ì‚¬ì§„ ì—…ë¡œë“œ ì˜ì—­ì¸ì§€ í™•ì¸
                        const isBackgroundArea = area.querySelector('#backgroundInput') || 
                                               area.previousElementSibling?.id === 'backgroundInput';
                        
                        if (isBackgroundArea) {
                            backgroundInput.files = files;
                            backgroundInput.dispatchEvent(new Event('change'));
                        } else {
                            calligraphyInput.files = files;
                            calligraphyInput.dispatchEvent(new Event('change'));
                        }
                    }
                }
            });
        });
        
        // í–„ë²„ê±° ë©”ë‰´ ë™ì‘
        const menuBtn = document.getElementById('menu-hamburger');
        const menuPopup = document.getElementById('menu-popup');
        menuBtn.onclick = (e) => {
          e.stopPropagation();
          menuPopup.style.display = (menuPopup.style.display === 'none' || menuPopup.style.display === '') ? 'block' : 'none';
        };
        // ë©”ë‰´ ë°”ê¹¥ í´ë¦­ ì‹œ ë‹«ê¸°
        window.addEventListener('click', (e) => {
          if (menuPopup.style.display === 'block' && !menuPopup.contains(e.target) && e.target !== menuBtn) {
            menuPopup.style.display = 'none';
          }
        });
        
        // ì°½ í¬ê¸° ë³€ê²½ ì‹œ ë°°ê²½ ì´ë¯¸ì§€ ì¬ì¡°ì •
        window.addEventListener('resize', () => {
            const compositeBackground = document.getElementById('compositeBackground');
            if (compositeBackground && compositeBackground.src) {
                setTimeout(() => {
                    adjustBackgroundImageSize(compositeBackground);
                }, 100);
            }
        });
        
        // ì´ˆê¸°í™”
        showStep(1);
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë‹¨ê³„ í‘œì‹œ ì´ˆê¸°í™”
        window.addEventListener('load', () => {
            showStep(1);
        });
    </script>
</body>
</html>
